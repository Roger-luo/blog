<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rogerluo.me","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="How hard is it to build your own top performance quantum circuit simulator? Does it really needs thousands of lines of code to implement it?At least in Julia language, you don’t! We can easily achieve">
<meta property="og:type" content="article">
<meta property="og:title" content="Build your own Top Performance Quantum Circuit Simulator in ONE DAY!">
<meta property="og:url" content="http://rogerluo.me/blog/2020/03/31/yany/index.html">
<meta property="og:site_name" content="Half Integer">
<meta property="og:description" content="How hard is it to build your own top performance quantum circuit simulator? Does it really needs thousands of lines of code to implement it?At least in Julia language, you don’t! We can easily achieve">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://rogerluo.me/images/implement-your-own-qc-simulator/kron-X-X.png">
<meta property="og:image" content="http://rogerluo.me/images/implement-your-own-qc-simulator/chain-X-X.png">
<meta property="og:image" content="http://rogerluo.me/images/implement-your-own-qc-simulator/benchmark.png">
<meta property="article:published_time" content="2020-03-31T05:22:18.000Z">
<meta property="article:modified_time" content="2020-12-21T23:30:35.495Z">
<meta property="article:author" content="Xiu-Zhe (Roger) Luo">
<meta property="article:tag" content="quantum-computing">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://rogerluo.me/images/implement-your-own-qc-simulator/kron-X-X.png">

<link rel="canonical" href="http://rogerluo.me/blog/2020/03/31/yany/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Build your own Top Performance Quantum Circuit Simulator in ONE DAY! | Half Integer</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Half Integer</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Xiu-Zhe (Roger) Luo's Blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rogerluo.me/blog/2020/03/31/yany/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xiu-Zhe (Roger) Luo">
      <meta itemprop="description" content="Where I writes about Machine Learning, Quanutm Physics, and more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Half Integer">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Build your own Top Performance Quantum Circuit Simulator in ONE DAY!
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-31 01:22:18" itemprop="dateCreated datePublished" datetime="2020-03-31T01:22:18-04:00">2020-03-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-21 18:30:35" itemprop="dateModified" datetime="2020-12-21T18:30:35-05:00">2020-12-21</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2020/03/31/yany/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/03/31/yany/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>How hard is it to build your own top performance quantum circuit simulator? Does it really needs thousands of lines of code to implement it?<br>At least in Julia language, you don’t! We can easily achieve top performance via a few hundreds of code while supporting<br>CUDA and symbolic calculation.</p>
<p>Like my previous blog posts, you can do it in ONE DAY as well. I’ll introduce how to do this with Julia language while going<br>through some common tricks for high performance computing in Julia language. I won’t talk much about the Julia language itself<br>or it will be a very long blog post, thus if you want to follow this blog post but you don’t know how to use the Julia programming<br>language yet, I would suggest you to checkout materials <a target="_blank" rel="noopener" href="https://julialang.org/learning/">here</a> first.</p>
<h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Quantum_computing">Quantum computing</a> has been a popular research topic in recent years. And building simulators can be useful for related research. I’m not going to give you a full introduction of what is quantum computing in this blog post, but I find you <a target="_blank" rel="noopener" href="https://youtu.be/F_Riqjdh2oM">this nice tutorial from Microsoft</a> if you are<br>interested in knowing what is the quantum computing. And you don’t really need to understand everything about quantum computing to follow this blog post - the emulator itself is just about special matrix-vector or matrix-matrix multiplication.</p>
<p>So to be simple, simulating quantum circuits, or to be more specific simulating how quantum circuits act on a quantum register, is about how to calculate large matrix-vector multiplication that scales exponentially. The vector contains the so-called quantum state and the matrices are quantum gate, which are usually small. The diagram of quantum circuits is a representation of these matrix multiplications. </p>
<p>For example, the X gate is just a small matrix</p>
<p>$$<br>\begin{pmatrix}<br>0 &amp; 1\\<br>1 &amp; 0<br>\end{pmatrix}<br>$$ </p>
<p>In theory, there is no way to simulate a general quantum circuit (more precisely, a universal gate set) efficiently, however, in practice, we could still do it within a rather small scale with some tricks that make use of the structure of the gates.</p>
<p>To know how to calculate a quantum circuit in the most naive way, we need to know two kinds of mathematical operations</p>
<p><strong>Tensor Product/Kronecker Product</strong>, this is represented as two parallel lines in the quantum circuit diagram, e.g</p>
<p><img src="/images/implement-your-own-qc-simulator/kron-X-X.png" alt="kron(X, X)"></p>
<p>and by definition, this can be calculated by</p>
<p>$$<br>\begin{pmatrix}<br>a_{11} &amp; a_{12} \\<br>a_{21} &amp; a_{22}<br>\end{pmatrix} \otimes<br>\begin{pmatrix}<br>b_{11} &amp; b_{12} \\<br>b_{21} &amp; b_{22}<br>\end{pmatrix} =<br>\begin{pmatrix}<br>a_{11} \begin{pmatrix}<br>b_{11} &amp; b_{12} \\<br>b_{21} &amp; b_{22}<br>\end{pmatrix} &amp; a_{12} \begin{pmatrix}<br>b_{11} &amp; b_{12} \\<br>b_{21} &amp; b_{22}<br>\end{pmatrix} \\<br>a_{21} \begin{pmatrix}<br>b_{11} &amp; b_{12} \\<br>b_{21} &amp; b_{22}<br>\end{pmatrix} &amp; a_{22} \begin{pmatrix}<br>b_{11} &amp; b_{12} \\<br>b_{21} &amp; b_{22}<br>\end{pmatrix}<br>\end{pmatrix}<br>$$</p>
<p><strong>Matrix Multiplication</strong>, this is the most basic linear algebra operation, I’ll skip introducing this. In quantum circuit diagram, this is represented by blocks connected by lines.</p>
<p><img src="/images/implement-your-own-qc-simulator/chain-X-X.png" alt="X-X"></p>
<p>As a conclusion of this section, you can see simulating how pure quantum circuits act on a given quantum state is about how to implement some special type of matrix-vector multiplication<br>efficiently. If you know about BLAS (Basic Linear Algebra Subprograms), you will realize this kind of operations are only BLAS level 2 operations, which does not require any smart tiling<br>technique and are mainly limited by memory bandwidth.</p>
<p>So let’s do it!</p>
<h2 id="Implementing-general-unitary-gate"><a href="#Implementing-general-unitary-gate" class="headerlink" title="Implementing general unitary gate"></a>Implementing general unitary gate</h2><p>Thus the simplest way of simulating a quantum circuit is very straightforward: we can just make use of Julia’s builtin functions:<br><code>kron</code> and <code>*</code>.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> LinearAlgebra</span><br><span class="line"><span class="keyword">function</span> naive_broutine!(r::<span class="built_in">AbstractVector</span>, U::<span class="built_in">AbstractMatrix</span>, loc::<span class="built_in">Int</span>)</span><br><span class="line">    n = <span class="built_in">Int</span>(log2(length(r))) <span class="comment"># get the number of qubits</span></span><br><span class="line">    <span class="keyword">return</span> kron(I(<span class="number">1</span>&lt;&lt;(n-loc+<span class="number">1</span>)), U), I(<span class="number">1</span>&lt;&lt;loc)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>However, this is obviously very inefficient: </p>
<ol>
<li>we need to allocate a $2^n \times 2^n$ matrix every time we try to evaluate the gate.</li>
<li>the length of the vector can only be $2^n$, thus we should be able to calculate it faster with this knowledge.</li>
</ol>
<hr>
<p>I’ll start from the easiest thing: if we know an integer is $2^n$, it is straight forward to find out $n$ by the following method</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">log2i(x::<span class="built_in">Int64</span>) = !signbit(x) ? (<span class="number">63</span> - leading_zeros(x)) : throw(<span class="built_in">ErrorException</span>(<span class="string">&quot;nonnegative expected (<span class="variable">$x</span>)&quot;</span>))</span><br><span class="line">log2i(x::<span class="built_in">UInt64</span>) = <span class="number">63</span> - leading_zeros(x)</span><br></pre></td></tr></table></figure>
<p>this is because we already know how long our integer is in the program by looking at its type, thus simply minus the number of leading zeros would give us the answer.<br>But don’t forget to raise an error when it’s an signed integer type. We can make this work on any integer type by the following way</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> N <span class="keyword">in</span> [<span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>]</span><br><span class="line">    T = <span class="built_in">Symbol</span>(:<span class="built_in">Int</span>, N)</span><br><span class="line">    UT = <span class="built_in">Symbol</span>(:<span class="built_in">UInt</span>, N)</span><br><span class="line">    <span class="meta">@eval</span> <span class="keyword">begin</span></span><br><span class="line">        log2i(x::$T) =</span><br><span class="line">            !signbit(x) ? ($(N - <span class="number">1</span>) - leading_zeros(x)) :</span><br><span class="line">            throw(<span class="built_in">ErrorException</span>(<span class="string">&quot;nonnegative expected (<span class="variable">$x</span>)&quot;</span>))</span><br><span class="line">        log2i(x::$UT) = $(N - <span class="number">1</span>) - leading_zeros(x)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>the command <code>@eval</code> here is called a macro in Julia programming language, it can be used to generate code. The above code generates the implementation of <code>log2i</code> for signed<br>and unsigned integer types from 8 bits to 128 bits.</p>
<hr>
<p>Let’s now consider how to write the general unitary gate acting on given locations of qubits.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> broutine!(r::<span class="built_in">AbstractVector</span>, U::<span class="built_in">AbstractMatrix</span>, locs::<span class="built_in">NTuple</span>&#123;N, <span class="built_in">Int</span>&#125;) <span class="keyword">where</span> N</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>this matrix will act on some certain qubits in the register, e.g given a 8x8 matrix we want it to act on the 1st, 4th and 5th qubit. Based on the implementation of X and Z we know this is about multiplying this matrix on the subspace of 1st, 4th and 5th qubit, which means we need to construct a set of new vectors whose indices iterate over the subspace of <code>0xx00x</code>, <code>0xx01x</code>, <code>0xx10x</code>, <code>0xx11x</code> etc. Thus the first thing we need to do is to find a generic way to iterate through the subspace of <code>0xx00x</code> then by adding an offset such as <code>1&lt;&lt;1</code> to each index in this subspace, we can get the subspace of <code>0xx01x</code> etc.</p>
<h3 id="Iterate-through-the-subspace"><a href="#Iterate-through-the-subspace" class="headerlink" title="Iterate through the subspace"></a>Iterate through the subspace</h3><p>To iterate through the subspace, we could iterate through all indices in the subspace. For each index, we move each bit to its position in the whole space (from first bit to the last).<br>This will give us the first subspace which is <code>0xx00x</code>.</p>
<hr>
<p>Before we move on, I need to introduce the concept of binary masks: it is an integer that can help us “filter” out some binary values, e.g<br>we want to know if a given integer’s 4th and 5th bit, we can use a mask <code>0b11000</code>, where its 4th and 5th bit are <code>1</code> the rest is <code>0</code>, then we<br>can use an and operation get get the value. Given the location of bits, we can create a binary mask via the following <code>bmask</code> function</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> bmask(itr)</span><br><span class="line">    isempty(itr) &amp;&amp; <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    ret = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> b <span class="keyword">in</span> itr</span><br><span class="line">        ret += <span class="number">1</span> &lt;&lt; (b - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>where <code>itr</code> is some iterable. However there are quite a few cases that we don’t need to create it via a for-loop, so we can specialize this function<br>on the following types</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> bmask(range::<span class="built_in">UnitRange</span>&#123;<span class="built_in">Int</span>&#125;)</span><br><span class="line">    ((<span class="number">1</span> &lt;&lt; (range.stop - range.start + <span class="number">1</span>)) - <span class="number">1</span>) &lt;&lt; (range.start - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>however, we maybe want to make the implementation more general for arbitrary integer types, so let’s use a type variable <code>T</code>!</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> bmask(::<span class="built_in">Type</span>&#123;T&#125;, itr) <span class="keyword">where</span> &#123;T&lt;:<span class="built_in">Integer</span>&#125;</span><br><span class="line">    isempty(itr) &amp;&amp; <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    ret = zero(T)</span><br><span class="line">    <span class="keyword">for</span> b <span class="keyword">in</span> itr</span><br><span class="line">        ret += one(T) &lt;&lt; (b - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> bmask(::<span class="built_in">Type</span>&#123;T&#125;, range::<span class="built_in">UnitRange</span>&#123;<span class="built_in">Int</span>&#125;)::T <span class="keyword">where</span> &#123;T&lt;:<span class="built_in">Integer</span>&#125;</span><br><span class="line">    ((one(T) &lt;&lt; (range.stop - range.start + <span class="number">1</span>)) - one(T)) &lt;&lt; (range.start - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>However after we put a type variable as the first argument, it is not convenient when we just want to use <code>Int64</code> anymore,<br>let’s create a few convenient methods then</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bmask(args...) = bmask(<span class="built_in">Int</span>, args...)</span><br><span class="line"><span class="comment"># this is for removing the infinity call of the later function</span></span><br><span class="line">bmask(::<span class="built_in">Type</span>&#123;T&#125;) <span class="keyword">where</span> &#123;T&lt;:<span class="built_in">Integer</span>&#125; = zero(T)</span><br><span class="line">bmask(::<span class="built_in">Type</span>&#123;T&#125;, positions::<span class="built_in">Int</span>...) <span class="keyword">where</span> &#123;T&lt;:<span class="built_in">Integer</span>&#125; = bmask(T, positions)</span><br></pre></td></tr></table></figure>
<p>The final implement would look like the following</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">bmask(args...) = bmask(<span class="built_in">Int</span>, args...)</span><br><span class="line">bmask(::<span class="built_in">Type</span>&#123;T&#125;) <span class="keyword">where</span> &#123;T&lt;:<span class="built_in">Integer</span>&#125; = zero(T)</span><br><span class="line">bmask(::<span class="built_in">Type</span>&#123;T&#125;, positions::<span class="built_in">Int</span>...) <span class="keyword">where</span> &#123;T&lt;:<span class="built_in">Integer</span>&#125; = bmask(T, positions)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> bmask(::<span class="built_in">Type</span>&#123;T&#125;, itr) <span class="keyword">where</span> &#123;T&lt;:<span class="built_in">Integer</span>&#125;</span><br><span class="line">    isempty(itr) &amp;&amp; <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    ret = zero(T)</span><br><span class="line">    <span class="keyword">for</span> b <span class="keyword">in</span> itr</span><br><span class="line">        ret += one(T) &lt;&lt; (b - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> bmask(::<span class="built_in">Type</span>&#123;T&#125;, range::<span class="built_in">UnitRange</span>&#123;<span class="built_in">Int</span>&#125;)::T <span class="keyword">where</span> &#123;T&lt;:<span class="built_in">Integer</span>&#125;</span><br><span class="line">    ((one(T) &lt;&lt; (range.stop - range.start + <span class="number">1</span>)) - one(T)) &lt;&lt; (range.start - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<hr>
<p>To move the bits in subspace to the right position, we need to iterate through all the contiguous region in the bitstring, e.g for <code>0xx00x</code>, we<br>move the 2nd and 3rd bit in subspace by 3 bits together, this can be achieved by using a bit mask <code>001</code> and the following binary operation</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(xxx &amp; ~<span class="number">0b001</span>) &lt;&lt; <span class="number">1</span> + (xxx &amp; <span class="number">0b001</span>) <span class="comment"># = xx00x</span></span><br></pre></td></tr></table></figure>
<p>we define this as a function called <code>lmove</code>:</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@inline</span> lmove(b::<span class="built_in">Int</span>, mask::<span class="built_in">Int</span>, k::<span class="built_in">Int</span>)::<span class="built_in">Int</span> = (b &amp; ~mask) &lt;&lt; k + (b &amp; mask)</span><br></pre></td></tr></table></figure>
<p>we mark this function <a target="_blank" rel="noopener" href="https://docs.julialang.org/en/v1/base/base/#Base.@inline"><code>@inline</code></a><br>here to make sure the compiler will always inline it,<br>now we need to generate all the masks by counting contiguous region of the given locations</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> group_shift(locations)</span><br><span class="line">    masks = <span class="built_in">Int</span>[]</span><br><span class="line">    region_lens = <span class="built_in">Int</span>[]</span><br><span class="line">    k_prv = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> locations</span><br><span class="line">        <span class="comment"># if current position in the contiguous region</span></span><br><span class="line">        <span class="comment"># since these bits will be moved together with</span></span><br><span class="line">        <span class="comment"># the first one, we don&#x27;t need to generate a</span></span><br><span class="line">        <span class="comment"># new mask</span></span><br><span class="line">        <span class="keyword">if</span> k == k_prv + <span class="number">1</span></span><br><span class="line">            region_lens[<span class="keyword">end</span>] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment"># we generate a bit mask where the 1st to k-th bits are 1</span></span><br><span class="line">            push!(masks, bmask(<span class="number">0</span>:k-<span class="number">1</span>))</span><br><span class="line">            push!(region_lens, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        k_prv = k</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> masks, region_lens</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>now to get the index in the whole space, we simply move each contiguous region by the length of their region,</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> <span class="number">1</span>:n_regions</span><br><span class="line">    index = lmove(index, masks[s], region_lens[s])</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>where the initial value of <code>index</code> is the subspace index, and after the loop, we will get the index in the whole space.</p>
<p>Now, since we need to iterate the all the possible indices, it would be very convenient to have an iterator, let’s implement<br>this as an iterator,</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> BitSubspace</span><br><span class="line">    n::<span class="built_in">Int</span> <span class="comment"># total number of bits</span></span><br><span class="line">    n_subspace::<span class="built_in">Int</span> <span class="comment"># number of bits in the subspace</span></span><br><span class="line">    masks::<span class="built_in">Vector</span>&#123;<span class="built_in">Int</span>&#125; <span class="comment"># masks</span></span><br><span class="line">    region_lens::<span class="built_in">Vector</span>&#123;<span class="built_in">Int</span>&#125; <span class="comment"># length of each region</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>and we can construct it via</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> BitSubspace(n::<span class="built_in">Int</span>, locations)</span><br><span class="line">    masks, region_lens = group_shift(locations)</span><br><span class="line">    BitSubspace(<span class="number">1</span> &lt;&lt; (n - length(locations)), length(masks), masks, region_lens)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>now, let’s consider the corresponding whole-space index of each index in the subspace.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@inline</span> <span class="keyword">function</span> Base.getindex(it::BitSubspace, i)</span><br><span class="line">    index = i - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> <span class="number">1</span>:it.n_subspace</span><br><span class="line">        <span class="meta">@inbounds</span> index = lmove(index, it.masks[s], it.region_lens[s])</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> index</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>now let’s overload some methods to make this object become an iterable object</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Base.length(it::BitSubspace) = it.n</span><br><span class="line">Base.eltype(::BitSubspace) = <span class="built_in">Int</span></span><br><span class="line"><span class="meta">@inline</span> <span class="keyword">function</span> Base.iterate(it::BitSubspace, st = <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> st &gt; length(it)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nothing</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> it[st], st + <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>let’s try it! it works!</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; <span class="keyword">for</span> each <span class="keyword">in</span> BitSubspace(<span class="number">5</span>, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">            println(string(each, base=<span class="number">2</span>, pad=<span class="number">7</span>))</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line"><span class="number">00000</span></span><br><span class="line"><span class="number">00010</span></span><br><span class="line"><span class="number">10000</span></span><br><span class="line"><span class="number">10010</span></span><br></pre></td></tr></table></figure>
<h3 id="Multiply-matrix-in-subspace"><a href="#Multiply-matrix-in-subspace" class="headerlink" title="Multiply matrix in subspace"></a>Multiply matrix in subspace</h3><p>now we know how to generate the indices in a subspace, we need to multiply the matrix to each subspace,<br>e.g for a unitary on the 1, 3, 4 qubits of a 5-qubit register, we need to multiply the matrix at <code>0xx0x</code>,<br><code>0xx1x</code>, <code>1xx0x</code> and <code>1xx1x</code>. Thus we can create the subspace of <code>x00x0</code> by <code>BitSubspace(5, [1, 3, 4])</code><br>and subspace of <code>0xx0x</code> by <code>BitSubspace(5, [2, 5])</code>, then add each index in <code>x00x0</code> to <code>0xx0x</code>, which looks like</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">subspace1 = BitSubspace(<span class="number">5</span>, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">subspace2 = BitSubspace(<span class="number">5</span>, [<span class="number">2</span>, <span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Julia uses 1-based index, we need to convert it</span></span><br><span class="line">indices = collect(b + <span class="number">1</span> <span class="keyword">for</span> b <span class="keyword">in</span> subspace2)</span><br><span class="line"></span><br><span class="line"><span class="meta">@inbounds</span> <span class="keyword">for</span> i <span class="keyword">in</span> subspace1</span><br><span class="line">    <span class="comment"># add an offset i to all the indices of 0xx0x</span></span><br><span class="line">    <span class="comment"># this will give us 0xx0x, 0xx1x, 1xx0x, 1xx1x</span></span><br><span class="line">    idx = indices .+ i</span><br><span class="line">    state[idx] = U * state[idx] <span class="comment"># matrix multiplication on the subspace</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>now we notice <code>subspace2</code> is the complement subspace of <code>subspace1</code> because the full space if <code>[1, 2, 3, 4, 5]</code>, so let’s redefine our <code>BitSubspace</code><br>constructor a bit, now instead of define the constructor <code>BitSubspace(n, locations)</code> we define two functions to create this object <code>bsubspace(n, locations)</code> and<br><code>bcomspace(n, locations)</code> which stands for <em>binary subspace</em> and <em>binary complement space</em>, the function <code>bsubspace</code> will create <code>subspace1</code> and the function<br><code>bcomspace(n, locations)</code> will create <code>subspace2</code>.</p>
<p>They have some overlapping operations, so I move them to an internal function <code>_group_shift</code></p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@inline</span> <span class="keyword">function</span> group_shift(locations)</span><br><span class="line">    masks = <span class="built_in">Int</span>[]</span><br><span class="line">    shift_len = <span class="built_in">Int</span>[]</span><br><span class="line">    k_prv = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> locations</span><br><span class="line">        _group_shift(masks, shift_len, k, k_prv)</span><br><span class="line">        k_prv = k</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> masks, shift_len</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@inline</span> <span class="keyword">function</span> complement_group_shift(n::<span class="built_in">Int</span>, locations)</span><br><span class="line">    masks = <span class="built_in">Int</span>[]</span><br><span class="line">    shift_len = <span class="built_in">Int</span>[]</span><br><span class="line">    k_prv = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="number">1</span>:n</span><br><span class="line">        k <span class="keyword">in</span> locations &amp;&amp; <span class="keyword">continue</span></span><br><span class="line">        _group_shift(masks, shift_len, k, k_prv)</span><br><span class="line">        k_prv = k</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> masks, shift_len</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@inline</span> <span class="keyword">function</span> _group_shift(masks::<span class="built_in">Vector</span>&#123;<span class="built_in">Int</span>&#125;, shift_len::<span class="built_in">Vector</span>&#123;<span class="built_in">Int</span>&#125;, k::<span class="built_in">Int</span>, k_prv::<span class="built_in">Int</span>)</span><br><span class="line">    <span class="comment"># if current position in the contiguous region</span></span><br><span class="line">    <span class="comment"># since these bits will be moved together with</span></span><br><span class="line">    <span class="comment"># the first one, we don&#x27;t need to generate a</span></span><br><span class="line">    <span class="comment"># new mask</span></span><br><span class="line">    <span class="keyword">if</span> k == k_prv + <span class="number">1</span></span><br><span class="line">        shift_len[<span class="keyword">end</span>] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment"># we generate a bit mask where the 1st to k-th bits are 1</span></span><br><span class="line">        push!(masks, bmask(<span class="number">0</span>:k-<span class="number">1</span>))</span><br><span class="line">        push!(shift_len, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>thus our routine will look like the following</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> broutine!(st::<span class="built_in">AbstractVector</span>, U::<span class="built_in">AbstractMatrix</span>, locs::<span class="built_in">NTuple</span>&#123;N, <span class="built_in">Int</span>&#125;) <span class="keyword">where</span> N</span><br><span class="line">    n = log2dim1(st)</span><br><span class="line">    subspace = bsubspace(n, locs)</span><br><span class="line">    comspace = bcomspace(n, locs)</span><br><span class="line">    indices = [idx + <span class="number">1</span> <span class="keyword">for</span> idx <span class="keyword">in</span> comspace]</span><br><span class="line">    <span class="meta">@inbounds</span> <span class="meta">@views</span> <span class="keyword">for</span> k <span class="keyword">in</span> subspace</span><br><span class="line">        idx = indices .+ k</span><br><span class="line">        st[idx] = U * st[idx]</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> st</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>the <code>log2dim1</code> is just a convenient one-liner <code>log2dim1(x) = log2i(size(x, 1))</code>. And we use <a target="_blank" rel="noopener" href="https://docs.julialang.org/en/v1/base/base/#Base.@inbounds"><code>@inbounds</code></a> here to tell the Julia compiler<br>that we are pretty sure all our indices are inbounds! And use <a target="_blank" rel="noopener" href="https://docs.julialang.org/en/v1/base/arrays/#Base.@views"><code>@views</code></a> to tell Julia we are confident at mutating our arrays so please<br>use a <code>view</code> and don’t allocate any memory!</p>
<p>Now you may notice: the iteration in our implementation is independent and may be reordered! This means we can easily make this parallel. The simplest way to parallelize it is via multi-threading. In Julia, this is extremely simple,</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> threaded_broutine!(st::<span class="built_in">AbstractVector</span>, U::<span class="built_in">AbstractMatrix</span>, locs::<span class="built_in">NTuple</span>&#123;N, <span class="built_in">Int</span>&#125;) <span class="keyword">where</span> N</span><br><span class="line">    n = log2dim1(st)</span><br><span class="line">    subspace = bsubspace(n, locs)</span><br><span class="line">    comspace = bcomspace(n, locs)</span><br><span class="line">    indices = [idx + <span class="number">1</span> <span class="keyword">for</span> idx <span class="keyword">in</span> comspace]</span><br><span class="line">    <span class="meta">@inbounds</span> <span class="meta">@views</span> Threads.<span class="meta">@threads</span> <span class="keyword">for</span> k <span class="keyword">in</span> subspace</span><br><span class="line">        idx = indices .+ k</span><br><span class="line">        st[idx] = U * st[idx]</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> st</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>but wait, this will give you en error <code>MethodError: no method matching firstindex(::BitSubspace)</code>, this is simply because<br>the <code>@threads</code> wants calculate which indices it needs to put into one thread using <code>firstindex</code>, so let’s define it</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base.firstindex(::BitSubspace) = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>thus the final implementation of subspace would looks like the following</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@inline</span> <span class="keyword">function</span> _group_shift(masks::<span class="built_in">Vector</span>&#123;<span class="built_in">Int</span>&#125;, shift_len::<span class="built_in">Vector</span>&#123;<span class="built_in">Int</span>&#125;, k::<span class="built_in">Int</span>, k_prv::<span class="built_in">Int</span>)</span><br><span class="line">    <span class="comment"># if current position in the contiguous region</span></span><br><span class="line">    <span class="comment"># since these bits will be moved together with</span></span><br><span class="line">    <span class="comment"># the first one, we don&#x27;t need to generate a</span></span><br><span class="line">    <span class="comment"># new mask</span></span><br><span class="line">    <span class="keyword">if</span> k == k_prv + <span class="number">1</span></span><br><span class="line">        shift_len[<span class="keyword">end</span>] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment"># we generate a bit mask where the 1st to k-th bits are 1</span></span><br><span class="line">        push!(masks, bmask(<span class="number">0</span>:k-<span class="number">1</span>))</span><br><span class="line">        push!(shift_len, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@inline</span> <span class="keyword">function</span> group_shift(locations)</span><br><span class="line">    masks = <span class="built_in">Int</span>[]</span><br><span class="line">    shift_len = <span class="built_in">Int</span>[]</span><br><span class="line">    k_prv = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> locations</span><br><span class="line">        _group_shift(masks, shift_len, k, k_prv)</span><br><span class="line">        k_prv = k</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> masks, shift_len</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@inline</span> <span class="keyword">function</span> complement_group_shift(n::<span class="built_in">Int</span>, locations)</span><br><span class="line">    masks = <span class="built_in">Int</span>[]</span><br><span class="line">    shift_len = <span class="built_in">Int</span>[]</span><br><span class="line">    k_prv = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="number">1</span>:n</span><br><span class="line">        k <span class="keyword">in</span> locations &amp;&amp; <span class="keyword">continue</span></span><br><span class="line">        _group_shift(masks, shift_len, k, k_prv)</span><br><span class="line">        k_prv = k</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> masks, shift_len</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> BitSubspace</span><br><span class="line">    n::<span class="built_in">Int</span> <span class="comment"># number of bits in fullspace</span></span><br><span class="line">    sz_subspace::<span class="built_in">Int</span> <span class="comment"># size of the subspace</span></span><br><span class="line">    n_shifts::<span class="built_in">Int</span> <span class="comment"># number of shifts</span></span><br><span class="line">    masks::<span class="built_in">Vector</span>&#123;<span class="built_in">Int</span>&#125; <span class="comment"># shift masks</span></span><br><span class="line">    shift_len::<span class="built_in">Vector</span>&#123;<span class="built_in">Int</span>&#125; <span class="comment"># length of each shift</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> Base.getindex(s::BitSubspace, i::<span class="built_in">Int</span>)</span><br><span class="line">    index = i - <span class="number">1</span></span><br><span class="line">    <span class="meta">@inbounds</span> <span class="keyword">for</span> k <span class="keyword">in</span> <span class="number">1</span>:s.n_shifts</span><br><span class="line">        index = lmove(index, s.masks[k], s.shift_len[k])</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> index</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">Base.firstindex(s::BitSubspace) = <span class="number">1</span></span><br><span class="line">Base.lastindex(s::BitSubspace) = s.sz_subspace</span><br><span class="line">Base.length(s::BitSubspace) = s.sz_subspace</span><br><span class="line">Base.eltype(::BitSubspace) = <span class="built_in">Int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> Base.iterate(s::BitSubspace, st::<span class="built_in">Int</span> = <span class="number">1</span>)</span><br><span class="line">    st &lt;= length(s) || <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">return</span> s[st], st + <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> bsubspace(n::<span class="built_in">Int</span>, locs)</span><br><span class="line">    <span class="meta">@assert</span> issorted(locs)</span><br><span class="line">    masks, shift_len = group_shift(locs)</span><br><span class="line">    BitSubspace(n, <span class="number">1</span> &lt;&lt; (n - length(locs)), length(masks), masks, shift_len)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> bcomspace(n::<span class="built_in">Int</span>, locs)</span><br><span class="line">    <span class="meta">@assert</span> issorted(locs)</span><br><span class="line">    masks, shift_len = complement_group_shift(n, locs)</span><br><span class="line">    BitSubspace(n, <span class="number">1</span> &lt;&lt; length(locs), length(masks), masks, shift_len)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> broutine!(st::<span class="built_in">AbstractVector</span>, U::<span class="built_in">AbstractMatrix</span>, locs::<span class="built_in">NTuple</span>&#123;N, <span class="built_in">Int</span>&#125;) <span class="keyword">where</span> N</span><br><span class="line">    n = log2dim1(st)</span><br><span class="line">    subspace = bsubspace(n, locs)</span><br><span class="line">    comspace = bcomspace(n, locs)</span><br><span class="line">    indices = [idx + <span class="number">1</span> <span class="keyword">for</span> idx <span class="keyword">in</span> comspace]</span><br><span class="line">    <span class="meta">@inbounds</span> <span class="meta">@views</span> <span class="keyword">for</span> k <span class="keyword">in</span> subspace</span><br><span class="line">        idx = indices .+ k</span><br><span class="line">        st[idx] = U * st[idx]</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> st</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>here I changed the definition of <code>struct BitSubspace</code> to store the number of bits in fullspace so that we can print it nicely</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Base.show(io::<span class="built_in">IO</span>, ::<span class="string">MIME&quot;text/plain&quot;</span>, s::BitSubspace)</span><br><span class="line">    indent = get(io, :indent, <span class="number">0</span>)</span><br><span class="line">    println(io, <span class="string">&quot; &quot;</span>^indent, s.sz_subspace, <span class="string">&quot;-element BitSubspace:&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> s.sz_subspace &lt; <span class="number">5</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="number">1</span>:s.sz_subspace</span><br><span class="line">            print(io, <span class="string">&quot; &quot;</span>^(indent+<span class="number">1</span>), string(s[k]; base=<span class="number">2</span>, pad=s.n))</span><br><span class="line">            <span class="keyword">if</span> k != s.sz_subspace</span><br><span class="line">                println(io)</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="comment"># never print more than 4 elements</span></span><br><span class="line">        println(io, <span class="string">&quot; &quot;</span>^(indent+<span class="number">1</span>), string(s[<span class="number">1</span>]; base=<span class="number">2</span>, pad=s.n))</span><br><span class="line">        println(io, <span class="string">&quot; &quot;</span>^(indent+<span class="number">1</span>), string(s[<span class="number">2</span>]; base=<span class="number">2</span>, pad=s.n))</span><br><span class="line">        println(io, <span class="string">&quot; &quot;</span>^(indent+<span class="number">1</span>), <span class="string">&quot;⋮&quot;</span>)</span><br><span class="line">        println(io, <span class="string">&quot; &quot;</span>^(indent+<span class="number">1</span>), string(s[<span class="keyword">end</span>-<span class="number">1</span>]; base=<span class="number">2</span>, pad=s.n))</span><br><span class="line">        print(io, <span class="string">&quot; &quot;</span>^(indent+<span class="number">1</span>), string(s[<span class="keyword">end</span>]; base=<span class="number">2</span>, pad=s.n))</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>let’s try it!</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; bsubspace(<span class="number">5</span>, (<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"><span class="number">8</span>-element BitSubspace:</span><br><span class="line"> <span class="number">00000</span></span><br><span class="line"> <span class="number">00001</span></span><br><span class="line"> ⋮</span><br><span class="line"> <span class="number">11000</span></span><br><span class="line"> <span class="number">11001</span></span><br><span class="line"></span><br><span class="line">julia&gt; bcomspace(<span class="number">5</span>, (<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"><span class="number">4</span>-element BitSubspace:</span><br><span class="line"> <span class="number">00000</span></span><br><span class="line"> <span class="number">00010</span></span><br><span class="line"> <span class="number">00100</span></span><br><span class="line"> <span class="number">00110</span></span><br></pre></td></tr></table></figure>
<h2 id="Implement-controlled-gate"><a href="#Implement-controlled-gate" class="headerlink" title="Implement controlled gate"></a>Implement controlled gate</h2><p>Now I have introduced all the tricks for normal quantum gates, however, there are another important set of gates which is controlled gates.<br>There are no new tricks, but we will need to generalize the implementation above a little bit.</p>
<h3 id="General-controlled-unitary-gate"><a href="#General-controlled-unitary-gate" class="headerlink" title="General controlled unitary gate"></a>General controlled unitary gate</h3><p>Controlled unitary gate basically means when we see an index, e.g <code>010011</code>, except applying our unitary matrix on the given location (e.g <code>1</code> and <code>2</code>), we need to look<br>at the control qubit, if the control qubit is <code>0</code>, we do nothing, if the control qubit is <code>1</code> we apply the matrix. (for inverse control gate, this is opposite)<br>Thus, this means the subspace we will be looking at contains 2 parts: the bits on control locations are <code>1</code> and the bits on gate locations are <code>0</code>. We can define our<br>offset as following:</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl_offset(locs, configs) = bmask(locs[i] <span class="keyword">for</span> (i, u) <span class="keyword">in</span> enumerate(configs) <span class="keyword">if</span> u != <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>and the corresponding routine becomes</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> routine!(st::<span class="built_in">AbstractVector</span>, U::<span class="built_in">AbstractMatrix</span>, locs::<span class="built_in">NTuple</span>&#123;N, <span class="built_in">Int</span>&#125;, ctrl_locs::<span class="built_in">NTuple</span>&#123;M, <span class="built_in">Int</span>&#125;, ctrl_configs::<span class="built_in">NTuple</span>&#123;M, <span class="built_in">Int</span>&#125;) <span class="keyword">where</span> &#123;N, M&#125;</span><br><span class="line">    n = log2dim1(st)</span><br><span class="line">    subspace = bsubspace(n, sort([locs..., ctrl_locs...]))</span><br><span class="line">    comspace = bcomspace(n, locs)</span><br><span class="line">    offset = ctrl_offset(ctrl_locs, ctrl_configs)</span><br><span class="line">    indices = [idx + <span class="number">1</span> <span class="keyword">for</span> idx <span class="keyword">in</span> comspace]</span><br><span class="line">    <span class="meta">@inbounds</span> <span class="meta">@views</span> <span class="keyword">for</span> k <span class="keyword">in</span> subspace</span><br><span class="line">        idx = indices .+ k .+ offset</span><br><span class="line">        st[idx] = U * st[idx]</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> st</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="Optimize-performance-for-small-matrices"><a href="#Optimize-performance-for-small-matrices" class="headerlink" title="Optimize performance for small matrices"></a>Optimize performance for small matrices</h2><p>In most cases, the matrices of unitary gates we want to simulate are usually very small. They are usually of size <code>2x2</code> (1 qubit),<br><code>4x4</code> (2 qubit) or <code>8x8</code> (3 qubit). In these cases, we can consider using the <code>StaticArray</code> which is much faster than openBLAS/MKL for<br>small matrices, but we don’t need to change our <code>routine!</code> implementation, since Julia will specialize our generic functions<br>automatically:</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> BenchmarkTools, StaticArrays</span><br><span class="line">U1 = rand(<span class="built_in">ComplexF64</span>, <span class="number">8</span>, <span class="number">8</span>);</span><br><span class="line">U2 = <span class="meta">@SMatrix</span> rand(<span class="built_in">ComplexF64</span>, <span class="number">8</span>, <span class="number">8</span>);</span><br><span class="line">locs = (<span class="number">4</span>, <span class="number">9</span>, <span class="number">10</span>);</span><br><span class="line">st = rand(<span class="built_in">ComplexF64</span>, <span class="number">1</span>&lt;&lt;<span class="number">15</span>);</span><br></pre></td></tr></table></figure>
<p>and we can see the benchmark</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; <span class="meta">@benchmark</span> broutine!(r, $U1, $locs) setup=(r=copy($st))</span><br><span class="line">BenchmarkTools.Trial: </span><br><span class="line">  memory estimate:  <span class="number">1.38</span> MiB</span><br><span class="line">  allocs estimate:  <span class="number">8201</span></span><br><span class="line">  --------------</span><br><span class="line">  minimum time:     <span class="number">489.581</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  median time:      <span class="number">513.550</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  mean time:        <span class="number">539.640</span> μs (<span class="number">4.09</span>% GC)</span><br><span class="line">  maximum time:     <span class="number">1.403</span> ms (<span class="number">62.67</span>% GC)</span><br><span class="line">  --------------</span><br><span class="line">  samples:          <span class="number">8451</span></span><br><span class="line">  evals/sample:     <span class="number">1</span></span><br><span class="line"></span><br><span class="line">julia&gt; <span class="meta">@benchmark</span> broutine!(r, $U2, $locs) setup=(r=copy($st))</span><br><span class="line">BenchmarkTools.Trial: </span><br><span class="line">  memory estimate:  <span class="number">576.64</span> KiB</span><br><span class="line">  allocs estimate:  <span class="number">4105</span></span><br><span class="line">  --------------</span><br><span class="line">  minimum time:     <span class="number">182.967</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  median time:      <span class="number">188.346</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  mean time:        <span class="number">202.701</span> μs (<span class="number">6.45</span>% GC)</span><br><span class="line">  maximum time:     <span class="number">999.731</span> μs (<span class="number">80.77</span>% GC)</span><br><span class="line">  --------------</span><br><span class="line">  samples:          <span class="number">10000</span></span><br><span class="line">  evals/sample:     <span class="number">1</span></span><br></pre></td></tr></table></figure>
<hr>
<p>Using <code>StaticArray</code> is already very fast, But this is still space to optimize it, and because <code>StaticArray</code> will<br>store everything as a type in compile time, this will force us to compile things at runtime, which can make the first<br>time execution slow (since Julia uses <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Just-in-time_compilation">just-in-time</a> compilation,<br>it can specialize functions at runtime). Before we move forward, let me formalize the problem a bit more:</p>
<p>Now as you might have noticed, what we have been doing is implementing a matrix-vector multiplication but in subspace,<br>and we always know the indices inside the complement space, we just need to calculate its value in the full space, and<br>because of the control gates, we may need to add an offset to the indices in full space, but it is <code>0</code> by default,<br>thus this operation can be defined as following</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> subspace_mul!(st::<span class="built_in">AbstractVector</span>&#123;T&#125;, comspace, U, subspace, offset=<span class="number">0</span>) <span class="keyword">where</span> T</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>now let’s implement this in a plain <code>for</code> loop, if you happened to forget how to calculate matrix-vector multiplication,<br>an <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Einstein_notation">einstein summation notation</a> may help:</p>
<p>$$<br>st_{i_1,i_2,\cdots, p, \cdots, i_{n-1}, i_{n}} = U_{p,q} st_{i_1,i_2,\cdots, q, \cdots, i_{n-1}, i_{n}}<br>$$</p>
<p>where $U$ is a $2\times 2$ matrix and $p, q$ are indices in our subspace. Now we can write down our subspace multiplication<br>function</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> subspace_mul!(st::<span class="built_in">AbstractVector</span>&#123;T&#125;, comspace, U, subspace, offset=<span class="number">0</span>) <span class="keyword">where</span> T</span><br><span class="line">    indices = [idx + <span class="number">1</span> <span class="keyword">for</span> idx <span class="keyword">in</span> comspace]</span><br><span class="line">    y = similar(st, (size(U, <span class="number">1</span>), ))</span><br><span class="line">    idx = similar(indices)</span><br><span class="line"></span><br><span class="line">    <span class="meta">@inbounds</span> <span class="keyword">for</span> k <span class="keyword">in</span> subspace</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>:size(U, <span class="number">1</span>)</span><br><span class="line">            idx[i] = indices[i] + k + offset</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>:size(U, <span class="number">1</span>)</span><br><span class="line">            y[i] = zero(T)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">1</span>:size(U, <span class="number">2</span>)</span><br><span class="line">                y[i] += U[i, j] * st[idx[j]]</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>:size(U, <span class="number">1</span>)</span><br><span class="line">            st[idx[i]] = y[i]</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> st</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>if you are familiar with BLAS functions, there is a small difference with <code>gemv</code> routine: because we are doing multiplication<br>in a large space, we need to allocate a small vector to store intermediate result in the subspace and then assign the intermediate<br>result to the full space vector.</p>
<p>Now let’s use this implementation in our <code>broutine!</code> function:</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> broutine!(st::<span class="built_in">AbstractVector</span>, U::<span class="built_in">AbstractMatrix</span>, locs::<span class="built_in">NTuple</span>&#123;N, <span class="built_in">Int</span>&#125;) <span class="keyword">where</span> N</span><br><span class="line">    n = log2dim1(st)</span><br><span class="line">    subspace = bsubspace(n, locs)</span><br><span class="line">    comspace = bcomspace(n, locs)</span><br><span class="line">    subspace_mul!(st, comspace, U, subspace)</span><br><span class="line">    <span class="keyword">return</span> st</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> broutine!(st::<span class="built_in">AbstractVector</span>, U::<span class="built_in">AbstractMatrix</span>, locs::<span class="built_in">NTuple</span>&#123;N, <span class="built_in">Int</span>&#125;, ctrl_locs::<span class="built_in">NTuple</span>&#123;M, <span class="built_in">Int</span>&#125;, ctrl_configs::<span class="built_in">NTuple</span>&#123;M, <span class="built_in">Int</span>&#125;) <span class="keyword">where</span> &#123;N, M&#125;</span><br><span class="line">    n = log2dim1(st)</span><br><span class="line">    subspace = bsubspace(n, sort([locs..., ctrl_locs...]))</span><br><span class="line">    comspace = bcomspace(n, locs)</span><br><span class="line">    offset = ctrl_offset(ctrl_locs, ctrl_configs)</span><br><span class="line">    subspace_mul!(st, comspace, U, subspace, offset)</span><br><span class="line">    <span class="keyword">return</span> st</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>As you can see, it is faster now, but still slower than <code>StaticArrays</code>, this is because our compiler still has no access to the shape information<br>of your matrix</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; <span class="meta">@benchmark</span> broutine!(r, $U1, $locs) setup=(r=copy($st))</span><br><span class="line">BenchmarkTools.Trial: </span><br><span class="line">  memory estimate:  <span class="number">1008</span> bytes</span><br><span class="line">  allocs estimate:  <span class="number">11</span></span><br><span class="line">  --------------</span><br><span class="line">  minimum time:     <span class="number">247.516</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  median time:      <span class="number">282.016</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  mean time:        <span class="number">281.811</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  maximum time:     <span class="number">489.902</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  --------------</span><br><span class="line">  samples:          <span class="number">10000</span></span><br><span class="line">  evals/sample:     <span class="number">1</span></span><br></pre></td></tr></table></figure>
<hr>
<p>A direct observation is that the inner loop has a very small size in the case of quantum gates</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>:size(U, <span class="number">1</span>)</span><br><span class="line">   y[i] = zero(T)</span><br><span class="line">   <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">1</span>:size(U, <span class="number">2</span>)</span><br><span class="line">       y[i] += U[i, j] * st[idx[j]]</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>if <code>U</code> is a 2x2 matrix, this can be written as</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T1 = U[<span class="number">1</span>, <span class="number">1</span>] * st[idx[<span class="number">1</span>]] + U[<span class="number">1</span>, <span class="number">2</span>] * st[idx[<span class="number">2</span>]]</span><br><span class="line">T2 = U[<span class="number">2</span>, <span class="number">1</span>] * st[idx[<span class="number">1</span>]] + U[<span class="number">2</span>, <span class="number">2</span>] * st[idx[<span class="number">2</span>]]</span><br></pre></td></tr></table></figure>
<p>first you will find we don’t need our intermediate array <code>y</code> anymore! And moreover, notice that the order of <code>T1</code> and <code>T2</code> doesn’t matter<br>for this calculation, which means in principal they can be executed in parallel! But this is an inner loop, we don’t want to waste our<br>multi-thread resources to parallel it, instead we hope we can have <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/SIMD">SIMD</a>. However, we don’t have to<br>call SIMD instructions explicitly, because in fact the compiler<br>can figure out how to use SIMD instructions for the 2x2 case itself, since it’s very obvious, and also because we have implicitly implied that we only<br>have a matrix of shape 2x2 by expanding the loop. So let’s just trust our compiler</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> subspace_mul2x2!(st::<span class="built_in">AbstractVector</span>&#123;T&#125;, comspace, U, subspace, offset=<span class="number">0</span>) <span class="keyword">where</span> T</span><br><span class="line">    indices_1 = comspace[<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">    indices_2 = comspace[<span class="number">2</span>] + <span class="number">1</span></span><br><span class="line">    <span class="meta">@inbounds</span> <span class="keyword">for</span> k <span class="keyword">in</span> subspace</span><br><span class="line">        idx_1 = indices_1 + k + offset</span><br><span class="line">        idx_2 = indices_2 + k + offset</span><br><span class="line"></span><br><span class="line">        T1 = U[<span class="number">1</span>, <span class="number">1</span>] * st[idx_1] + U[<span class="number">1</span>, <span class="number">2</span>] * st[idx_2]</span><br><span class="line">        T2 = U[<span class="number">2</span>, <span class="number">1</span>] * st[idx_1] + U[<span class="number">2</span>, <span class="number">2</span>] * st[idx_2]</span><br><span class="line"></span><br><span class="line">        st[idx_1] = T1</span><br><span class="line">        st[idx_2] = T2</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> st</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>we can do similar things for <code>4x4</code> and <code>8x8</code> matrices, implementing them is quite mechanical, thus we will seek some macro magic<br>now</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> subspace_mul4x4!(st::<span class="built_in">AbstractVector</span>&#123;T&#125;, comspace, U, subspace, offset=<span class="number">0</span>) <span class="keyword">where</span> T</span><br><span class="line">    Base.Cartesian.<span class="meta">@nextract</span> <span class="number">4</span> indices i -&gt; comspace[i] + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    Base.Cartesian.<span class="meta">@nextract</span> <span class="number">4</span> U i-&gt;<span class="keyword">begin</span></span><br><span class="line">        Base.Cartesian.<span class="meta">@nextract</span> <span class="number">4</span> U_i j-&gt;U[i, j]</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> subspace</span><br><span class="line">        Base.Cartesian.<span class="meta">@nextract</span> <span class="number">4</span> idx i-&gt; k + indices_i + offset</span><br><span class="line"></span><br><span class="line">        Base.Cartesian.<span class="meta">@nexprs</span> <span class="number">4</span> i -&gt; <span class="keyword">begin</span></span><br><span class="line">            y_i = zero(T)</span><br><span class="line">            Base.Cartesian.<span class="meta">@nexprs</span> <span class="number">4</span> j -&gt; <span class="keyword">begin</span></span><br><span class="line">                y_i += U_i_j * st[idx_j]</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        Base.Cartesian.<span class="meta">@nexprs</span> <span class="number">4</span> i -&gt; <span class="keyword">begin</span></span><br><span class="line">            st[idx_i] = y_i</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> st</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> subspace_mul8x8!(st::<span class="built_in">AbstractVector</span>&#123;T&#125;, comspace, U, subspace, offset=<span class="number">0</span>) <span class="keyword">where</span> T</span><br><span class="line">    Base.Cartesian.<span class="meta">@nextract</span> <span class="number">8</span> indices i -&gt; comspace[i] + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    Base.Cartesian.<span class="meta">@nextract</span> <span class="number">8</span> U i-&gt;<span class="keyword">begin</span></span><br><span class="line">        Base.Cartesian.<span class="meta">@nextract</span> <span class="number">8</span> U_i j-&gt;U[i, j]</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@inbounds</span> <span class="keyword">for</span> k <span class="keyword">in</span> subspace</span><br><span class="line">        Base.Cartesian.<span class="meta">@nextract</span> <span class="number">8</span> idx i-&gt; k + indices_i + offset</span><br><span class="line"></span><br><span class="line">        Base.Cartesian.<span class="meta">@nexprs</span> <span class="number">8</span> i -&gt; <span class="keyword">begin</span></span><br><span class="line">            y_i = zero(T)</span><br><span class="line">            Base.Cartesian.<span class="meta">@nexprs</span> <span class="number">8</span> j -&gt; <span class="keyword">begin</span></span><br><span class="line">                y_i += U_i_j * st[idx_j]</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        Base.Cartesian.<span class="meta">@nexprs</span> <span class="number">8</span> i -&gt; <span class="keyword">begin</span></span><br><span class="line">            st[idx_i] = y_i</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> st</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>In Julia the macro <code>Base.Cartesian.@nextract</code> will generate a bunch of variables like <code>indices_1</code>, <code>indice_2</code> etc.<br>automatically at compile time for us, so we don’t need to do it ourselves. And then we can use <code>Base.Cartesian.@nexprs</code><br>to implement the matrix multiplication statements and assign the values back to full space vector <code>st</code>. If you have questions<br>about how to use <code>Base.Cartesian.@nextract</code> and <code>Base.Cartesian.@nexprs</code> you can use the help mode in Julia REPL to check their<br>documentation. Now we will want to dispatch the method <code>subspace_mul!</code> to these specialized methods when we have a <code>2x2</code>, <code>4x4</code><br>or <code>8x8</code> matrix, so we move our original plain-loop version <code>subspace_mul!</code> to a new function <code>subspace_mul_generic!</code>,<br>and dispatch methods based on the matrix size</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> subspace_mul!(st::<span class="built_in">AbstractVector</span>&#123;T&#125;, comspace, U, subspace, offset=<span class="number">0</span>) <span class="keyword">where</span> T</span><br><span class="line">    <span class="keyword">if</span> size(U, <span class="number">1</span>) == <span class="number">2</span></span><br><span class="line">        subspace_mul2x2!(st, comspace, U, subspace, offset)</span><br><span class="line">    <span class="keyword">elseif</span> size(U, <span class="number">1</span>) == <span class="number">4</span></span><br><span class="line">        subspace_mul4x4!(st, comspace, U, subspace, offset)</span><br><span class="line">    <span class="keyword">elseif</span> size(U, <span class="number">1</span>) == <span class="number">8</span></span><br><span class="line">        subspace_mul8x8!(st, comspace, U, subspace, offset)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        subspace_mul_generic!(st, comspace, U, subspace, offset)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> st</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>if we try it on our previous benchmark, we will see we are faster than <code>StaticArrays</code> now!</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; <span class="meta">@benchmark</span> broutine!(r, $U1, $locs) setup=(r=copy($st))</span><br><span class="line">BenchmarkTools.Trial: </span><br><span class="line">  memory estimate:  <span class="number">512</span> bytes</span><br><span class="line">  allocs estimate:  <span class="number">8</span></span><br><span class="line">  --------------</span><br><span class="line">  minimum time:     <span class="number">141.577</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  median time:      <span class="number">145.168</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  mean time:        <span class="number">145.998</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  maximum time:     <span class="number">169.246</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  --------------</span><br><span class="line">  samples:          <span class="number">10000</span></span><br><span class="line">  evals/sample:     <span class="number">1</span></span><br></pre></td></tr></table></figure>
<hr>
<p>now since most of the quantum gates are <code>2x2</code> matrices, we will focus more on this case, recall that in the <code>2x2</code> matrix case,<br>there is only one location to specify, this will allow us to directly iterate through the subspace by adding up <code>2^loc</code>, where<br>the variable <code>loc</code> is the integer represents the location of this gate. This will get us rid of all the heavier <code>BitSubspace</code> struct.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> broutine2x2!(st::<span class="built_in">AbstractVector</span>&#123;T&#125;, U::<span class="built_in">AbstractMatrix</span>, locs::<span class="built_in">Tuple</span>&#123;<span class="built_in">Int</span>&#125;) <span class="keyword">where</span> T</span><br><span class="line">    U11 = U[<span class="number">1</span>, <span class="number">1</span>]; U12 = U[<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">    U21 = U[<span class="number">2</span>, <span class="number">1</span>]; U22 = U[<span class="number">2</span>, <span class="number">2</span>];</span><br><span class="line">    step_1 = <span class="number">1</span> &lt;&lt; (first(locs) - <span class="number">1</span>)</span><br><span class="line">    step_2 = <span class="number">1</span> &lt;&lt; first(locs)</span><br><span class="line"></span><br><span class="line">    <span class="meta">@inbounds</span> <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>:step_2:size(st, <span class="number">1</span>)-step_1</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> j+<span class="number">1</span>:j+step_1</span><br><span class="line">            ST1 = U11 * st[i] + U12 * st[i + step_1]</span><br><span class="line">            ST2 = U21 * st[i] + U22 * st[i + step_1]</span><br><span class="line"></span><br><span class="line">            st[i] = ST1</span><br><span class="line">            st[i + step_1] = ST2</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> st</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>let’s compare this and <code>subspace_mul2x2!</code>, to be fair we will directly call <code>broutine!</code> and it will call <code>subspace_mul!</code> then dispatch to <code>subspace_mul2x2!</code>.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; U = rand(<span class="built_in">ComplexF64</span>, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">julia&gt; locs = (<span class="number">3</span>, );</span><br><span class="line"></span><br><span class="line">julia&gt; st = rand(<span class="built_in">ComplexF64</span>, <span class="number">1</span>&lt;&lt;<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">julia&gt; <span class="meta">@benchmark</span> broutine!(r, $U, $locs) setup=(r=copy($st))</span><br><span class="line">BenchmarkTools.Trial: </span><br><span class="line">  memory estimate:  <span class="number">512</span> bytes</span><br><span class="line">  allocs estimate:  <span class="number">8</span></span><br><span class="line">  --------------</span><br><span class="line">  minimum time:     <span class="number">67.639</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  median time:      <span class="number">81.669</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  mean time:        <span class="number">86.487</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  maximum time:     <span class="number">125.038</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  --------------</span><br><span class="line">  samples:          <span class="number">10000</span></span><br><span class="line">  evals/sample:     <span class="number">1</span></span><br><span class="line"></span><br><span class="line">julia&gt; <span class="meta">@benchmark</span> broutine2x2!(r, $U, $locs) setup=(r=copy($st))</span><br><span class="line">BenchmarkTools.Trial: </span><br><span class="line">  memory estimate:  <span class="number">0</span> bytes</span><br><span class="line">  allocs estimate:  <span class="number">0</span></span><br><span class="line">  --------------</span><br><span class="line">  minimum time:     <span class="number">63.419</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  median time:      <span class="number">64.369</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  mean time:        <span class="number">64.757</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  maximum time:     <span class="number">86.489</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  --------------</span><br><span class="line">  samples:          <span class="number">10000</span></span><br><span class="line">  evals/sample:     <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>this is only a little bit faster. Hmm, this is not very ideal, but notice that because <code>step_1</code> can<br>be very small and it is an inner loop, we can then unroll this loop as long as it is small, so we can<br>now manually write</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> broutine2x2!(st::<span class="built_in">AbstractVector</span>&#123;T&#125;, U::<span class="built_in">AbstractMatrix</span>, locs::<span class="built_in">Tuple</span>&#123;<span class="built_in">Int</span>&#125;) <span class="keyword">where</span> T</span><br><span class="line">    U11 = U[<span class="number">1</span>, <span class="number">1</span>]; U12 = U[<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">    U21 = U[<span class="number">2</span>, <span class="number">1</span>]; U22 = U[<span class="number">2</span>, <span class="number">2</span>];</span><br><span class="line">    step_1 = <span class="number">1</span> &lt;&lt; (first(locs) - <span class="number">1</span>)</span><br><span class="line">    step_2 = <span class="number">1</span> &lt;&lt; first(locs)</span><br><span class="line"></span><br><span class="line">    <span class="meta">@inbounds</span> <span class="keyword">if</span> step_1 == <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>:step_2:size(st, <span class="number">1</span>)-step_1</span><br><span class="line">            ST1 = U11 * st[j + <span class="number">1</span>] + U12 * st[j + <span class="number">1</span> + step_1]</span><br><span class="line">            ST2 = U21 * st[j + <span class="number">1</span>] + U22 * st[j + <span class="number">1</span> + step_1]</span><br><span class="line"></span><br><span class="line">            st[j + <span class="number">1</span>] = ST1</span><br><span class="line">            st[j + <span class="number">1</span> + step_1] = ST2</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">elseif</span> step_1 == <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>:step_2:size(st, <span class="number">1</span>)-step_1</span><br><span class="line">            Base.Cartesian.<span class="meta">@nexprs</span> <span class="number">2</span> i-&gt;<span class="keyword">begin</span></span><br><span class="line">                ST1 = U11 * st[j + i] + U12 * st[j + i + step_1]</span><br><span class="line">                ST2 = U21 * st[j + i] + U22 * st[j + i + step_1]</span><br><span class="line">                st[j + i] = ST1</span><br><span class="line">                st[j + i + step_1] = ST2    </span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">elseif</span> step_1 == <span class="number">4</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>:step_2:size(st, <span class="number">1</span>)-step_1</span><br><span class="line">            Base.Cartesian.<span class="meta">@nexprs</span> <span class="number">4</span> i-&gt;<span class="keyword">begin</span></span><br><span class="line">                ST1 = U11 * st[j + i] + U12 * st[j + i + step_1]</span><br><span class="line">                ST2 = U21 * st[j + i] + U22 * st[j + i + step_1]</span><br><span class="line">                st[j + i] = ST1</span><br><span class="line">                st[j + i + step_1] = ST2    </span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">elseif</span> step_1 == <span class="number">8</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>:step_2:size(st, <span class="number">1</span>)-step_1</span><br><span class="line">            Base.Cartesian.<span class="meta">@nexprs</span> <span class="number">8</span> i-&gt;<span class="keyword">begin</span></span><br><span class="line">                ST1 = U11 * st[j + i] + U12 * st[j + i + step_1]</span><br><span class="line">                ST2 = U21 * st[j + i] + U22 * st[j + i + step_1]</span><br><span class="line">                st[j + i] = ST1</span><br><span class="line">                st[j + i + step_1] = ST2    </span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>:step_2:size(st, <span class="number">1</span>)-step_1</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> j:<span class="number">8</span>:j+step_1-<span class="number">1</span></span><br><span class="line">                Base.Cartesian.<span class="meta">@nexprs</span> <span class="number">8</span> k-&gt;<span class="keyword">begin</span></span><br><span class="line">                    ST1 = U11 * st[i + k] + U12 * st[i + step_1 + k]</span><br><span class="line">                    ST2 = U21 * st[i + k] + U22 * st[i + step_1 + k]</span><br><span class="line">                    st[i + k] = ST1</span><br><span class="line">                    st[i + step_1 + k] = ST2</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> st</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>the last loop is also partially unrolled by slicing our iteration range.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; <span class="meta">@benchmark</span> broutine2x2!(r, $U, $locs) setup=(r=copy($st))</span><br><span class="line">BenchmarkTools.Trial: </span><br><span class="line">  memory estimate:  <span class="number">0</span> bytes</span><br><span class="line">  allocs estimate:  <span class="number">0</span></span><br><span class="line">  --------------</span><br><span class="line">  minimum time:     <span class="number">21.420</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  median time:      <span class="number">21.670</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  mean time:        <span class="number">21.818</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  maximum time:     <span class="number">45.829</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  --------------</span><br><span class="line">  samples:          <span class="number">10000</span></span><br><span class="line">  evals/sample:     <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>this is now much faster than <code>subspace_mul2x2!</code>, as you see, by slightly change the abstraction<br>we implement, we exposed a small loop that can be unrolled! So let’s delete our <code>subspace_mul2x2!</code><br>and use this method instead:</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> broutine!(st::<span class="built_in">AbstractVector</span>, U::<span class="built_in">AbstractMatrix</span>, locs::<span class="built_in">NTuple</span>&#123;N, <span class="built_in">Int</span>&#125;) <span class="keyword">where</span> N</span><br><span class="line">    size(U, <span class="number">1</span>) == <span class="number">2</span> &amp;&amp; <span class="keyword">return</span> broutine!(st, U, locs)</span><br><span class="line">    n = log2dim1(st)</span><br><span class="line">    subspace = bsubspace(n, locs)</span><br><span class="line">    comspace = bcomspace(n, locs)</span><br><span class="line">    subspace_mul!(st, comspace, U, subspace)</span><br><span class="line">    <span class="keyword">return</span> st</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<hr>
<p>now let’s think about how to unroll the small matrix for the controlled gate case: the term controlled gate simply means<br>when we see there is <code>1</code> (or <code>0</code> for inverse control) at the control location, we apply the matrix in subspace, or we don’t.<br>so we can just check the control location’s configuration inside the loop, to do this we can create two masks: a control<br>location mask <code>ctrl_mask</code> and a control flag mask <code>flag_mask</code></p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctrl_mask = bmask(ctrl_locs)</span><br><span class="line">flag_mask = reduce(+, <span class="number">1</span> &lt;&lt; (ctrl_locs[i] - <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>:length(ctrl_locs) <span class="keyword">if</span> ctrl_configs[i])</span><br></pre></td></tr></table></figure>
<p>then we just need to check the bits on <code>ctrl_locs</code> to see if they are the same with <code>flag_mask</code>, we can implement a function<br><code>ismatch</code> to do this</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ismatch(index::T, mask::T, target::T) <span class="keyword">where</span> &#123;T&lt;:<span class="built_in">Integer</span>&#125; = (index &amp; mask) == target</span><br></pre></td></tr></table></figure>
<p>thus the implementation will look very similar to the un-controlled one, although it is evil to<br>copy-past, to be able to implement it within a day, I’ll just do so</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> broutine2x2!(st::<span class="built_in">AbstractVector</span>, U::<span class="built_in">AbstractMatrix</span>, locs::<span class="built_in">Tuple</span>&#123;<span class="built_in">Int</span>&#125;, ctrl_locs::<span class="built_in">NTuple</span>&#123;M, <span class="built_in">Int</span>&#125;, ctrl_configs::<span class="built_in">NTuple</span>&#123;M, <span class="built_in">Int</span>&#125;) <span class="keyword">where</span> &#123;N, M&#125;</span><br><span class="line">    step_1 = <span class="number">1</span> &lt;&lt; (first(locs) - <span class="number">1</span>)</span><br><span class="line">    step_2 = <span class="number">1</span> &lt;&lt; first(locs)</span><br><span class="line">    ctrl_mask = bmask(ctrl_locs)</span><br><span class="line">    flag_mask = reduce(+, <span class="number">1</span> &lt;&lt; (ctrl_locs[i] - <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>:length(ctrl_locs) <span class="keyword">if</span> ctrl_configs[i] == <span class="number">1</span>)</span><br><span class="line">    U11 = U[<span class="number">1</span>, <span class="number">1</span>]; U12 = U[<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">    U21 = U[<span class="number">2</span>, <span class="number">1</span>]; U22 = U[<span class="number">2</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="meta">@inbounds</span> <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>:step_2:size(st, <span class="number">1</span>)-step_1</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> j:j+step_1-<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> ismatch(i, ctrl_mask, flag_mask)</span><br><span class="line">                ST1 = U11 * st[i+<span class="number">1</span>] + U12 * st[i + step_1 + <span class="number">1</span>]</span><br><span class="line">                ST2 = U21 * st[i+<span class="number">1</span>] + U22 * st[i + step_1 + <span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">                st[i + <span class="number">1</span>] = ST1</span><br><span class="line">                st[i + step_1 + <span class="number">1</span>] = ST2</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> st</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>let’s now compare the performance</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; U = rand(<span class="built_in">ComplexF64</span>, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">julia&gt; locs = (<span class="number">3</span>, );</span><br><span class="line"></span><br><span class="line">julia&gt; ctrl = (<span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">julia&gt; flag = (<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">julia&gt; st = rand(<span class="built_in">ComplexF64</span>, <span class="number">1</span>&lt;&lt;<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">julia&gt; <span class="meta">@benchmark</span> broutine!(r, $U, $locs, $ctrl, $flag) setup=(r=copy($st))</span><br><span class="line">BenchmarkTools.Trial: </span><br><span class="line">  memory estimate:  <span class="number">736</span> bytes</span><br><span class="line">  allocs estimate:  <span class="number">10</span></span><br><span class="line">  --------------</span><br><span class="line">  minimum time:     <span class="number">17.380</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  median time:      <span class="number">23.989</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  mean time:        <span class="number">23.719</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  maximum time:     <span class="number">46.799</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  --------------</span><br><span class="line">  samples:          <span class="number">10000</span></span><br><span class="line">  evals/sample:     <span class="number">1</span></span><br><span class="line"></span><br><span class="line">julia&gt; <span class="meta">@benchmark</span> broutine2x2!(r, $U, $locs, $ctrl, $flag) setup=(r=copy($st))</span><br><span class="line">BenchmarkTools.Trial: </span><br><span class="line">  memory estimate:  <span class="number">80</span> bytes</span><br><span class="line">  allocs estimate:  <span class="number">3</span></span><br><span class="line">  --------------</span><br><span class="line">  minimum time:     <span class="number">8.283</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  median time:      <span class="number">8.423</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  mean time:        <span class="number">8.479</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  maximum time:     <span class="number">15.943</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  --------------</span><br><span class="line">  samples:          <span class="number">10000</span></span><br><span class="line">  evals/sample:     <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>Now the controlled single qubit gate routine is also improved a lot! Let’s dispatch to this too!</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> broutine!(st::<span class="built_in">AbstractVector</span>, U::<span class="built_in">AbstractMatrix</span>, locs::<span class="built_in">NTuple</span>&#123;N, <span class="built_in">Int</span>&#125;, ctrl_locs::<span class="built_in">NTuple</span>&#123;M, <span class="built_in">Int</span>&#125;, ctrl_configs::<span class="built_in">NTuple</span>&#123;M, <span class="built_in">Int</span>&#125;) <span class="keyword">where</span> &#123;N, M&#125;</span><br><span class="line">    size(U, <span class="number">1</span>) == <span class="number">2</span> &amp;&amp; <span class="keyword">return</span> broutine2x2!(st, U, locs, ctrl_locs, ctrl_configs)</span><br><span class="line">    n = log2dim1(st)</span><br><span class="line">    subspace = bsubspace(n, sort([locs..., ctrl_locs...]))</span><br><span class="line">    comspace = bcomspace(n, locs)</span><br><span class="line">    offset = ctrl_offset(ctrl_locs, ctrl_configs)</span><br><span class="line">    subspace_mul!(st, comspace, U, subspace, offset)</span><br><span class="line">    <span class="keyword">return</span> st</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="Parallelize-using-Multi-threads"><a href="#Parallelize-using-Multi-threads" class="headerlink" title="Parallelize using Multi-threads"></a>Parallelize using Multi-threads</h2><p>Now since we have implemented general matrix instructions, we should be able to simulate arbitrary quantum circuit. We can now parallel what we have implemented using multi-thread directly as we mentioned at the beginning. However, multi-threading is not always beneficial, it has a small overhead. Thus we may not want it when the number of qubits is not large enough.</p>
<p>We will implement a <code>@_threads</code> macro as following</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">macro</span> _threads(ex)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">quote</span></span><br><span class="line">        <span class="keyword">if</span> (Threads.nthreads() &gt; <span class="number">1</span>) &amp;&amp; (length(st) &gt; <span class="number">4096</span>)</span><br><span class="line">            $(<span class="built_in">Expr</span>(:macrocall, <span class="built_in">Expr</span>(:(.), :Threads, <span class="built_in">QuoteNode</span>(<span class="built_in">Symbol</span>(<span class="string">&quot;@threads&quot;</span>))), __source__, ex))</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            $ex</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span> |&gt; esc</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="Parallelize-using-CUDA"><a href="#Parallelize-using-CUDA" class="headerlink" title="Parallelize using CUDA"></a>Parallelize using CUDA</h2><p>Now, we have implemented Pauli gates and a general matrix instructions. Let’s parallelize them using <a target="_blank" rel="noopener" href="https://github.com/JuliaGPU/CUDA.jl">CUDA.jl</a>. Since we are not using general purpose matrix multiplication anymore, we need to write our<br>own CUDA kernels, but this is actually not very hard in Julia, because we can reuse a lot code from our previous implementation.</p>
<p>But before we start doing this, let me explain what is a kernel function in the context of CUDA programming. As you might have known, GPU devices<br>are special chip designed for executing a lot similar tasks in parallel. These tasks can be described via a function. Executing the kernel function<br>on GPU is in equivalent to execute this function on CPU within a huge loop.</p>
<p>So as you have realized, this kernel function is exactly the same thing we unrolled in previous implementation. Thus we can quickly turn out previous CPU<br>implementation into GPU implementation by wrapping the kernel into a closure, which is very mechanical. Although, the best way to do this is to move the<br>overlapping part into a function, to demonstrate things more clearly in the blog post I just simply copy paste the previous implementation.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> broutine!(st::CuVector&#123;T&#125;, U::<span class="built_in">AbstractMatrix</span>, locs::<span class="built_in">Tuple</span>&#123;<span class="built_in">Int</span>&#125;) <span class="keyword">where</span> T</span><br><span class="line">    U11 = U[<span class="number">1</span>, <span class="number">1</span>]; U12 = U[<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">    U21 = U[<span class="number">2</span>, <span class="number">1</span>]; U22 = U[<span class="number">2</span>, <span class="number">2</span>];</span><br><span class="line">    step_1 = <span class="number">1</span> &lt;&lt; (first(locs) - <span class="number">1</span>)</span><br><span class="line">    step_2 = <span class="number">1</span> &lt;&lt; first(locs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> kernel(st)</span><br><span class="line">        idx = (blockIdx().x - <span class="number">1</span>) * blockDim().x + threadIdx().x</span><br><span class="line">        j = step_2 * idx - step_2</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> j+<span class="number">1</span>:j+step_1</span><br><span class="line">            ST1 = U11 * st[i] + U12 * st[i + step_1]</span><br><span class="line">            ST2 = U21 * st[i] + U22 * st[i + step_1]</span><br><span class="line"></span><br><span class="line">            st[i] = ST1</span><br><span class="line">            st[i + step_1] = ST2</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    N = length(<span class="number">0</span>:step_2:size(st, <span class="number">1</span>)-step_1)</span><br><span class="line">    nblocks = ceil(<span class="built_in">Int</span>, N/<span class="number">256</span>)</span><br><span class="line">    <span class="meta">@cuda</span> threads=<span class="number">256</span> blocks=nblocks kernel(st)</span><br><span class="line">    <span class="keyword">return</span> st</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> broutine!(st::CuVector&#123;T&#125;, U::<span class="built_in">AbstractMatrix</span>, locs::<span class="built_in">Tuple</span>&#123;<span class="built_in">Int</span>&#125;, ctrl_locs::<span class="built_in">NTuple</span>&#123;M, <span class="built_in">Int</span>&#125;, ctrl_configs::<span class="built_in">NTuple</span>&#123;M, <span class="built_in">Int</span>&#125;) <span class="keyword">where</span> &#123;T, M&#125;</span><br><span class="line">    step_1 = <span class="number">1</span> &lt;&lt; (first(locs) - <span class="number">1</span>)</span><br><span class="line">    step_2 = <span class="number">1</span> &lt;&lt; first(locs)</span><br><span class="line">    ctrl_mask = bmask(ctrl_locs)</span><br><span class="line">    flag_mask = reduce(+, <span class="number">1</span> &lt;&lt; (ctrl_locs[i] - <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>:length(ctrl_locs) <span class="keyword">if</span> ctrl_configs[i] == <span class="number">1</span>)</span><br><span class="line">    U11 = U[<span class="number">1</span>, <span class="number">1</span>]; U12 = U[<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">    U21 = U[<span class="number">2</span>, <span class="number">1</span>]; U22 = U[<span class="number">2</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> kernel(st)</span><br><span class="line">        idx = (blockIdx().x - <span class="number">1</span>) * blockDim().x + threadIdx().x</span><br><span class="line">        j = step_2 * idx - step_2</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> j:j+step_1-<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> ismatch(i, ctrl_mask, flag_mask)</span><br><span class="line">                ST1 = U11 * st[i+<span class="number">1</span>] + U12 * st[i + step_1 + <span class="number">1</span>]</span><br><span class="line">                ST2 = U21 * st[i+<span class="number">1</span>] + U22 * st[i + step_1 + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">                st[i + <span class="number">1</span>] = ST1</span><br><span class="line">                st[i + step_1 + <span class="number">1</span>] = ST2</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    N = length(<span class="number">0</span>:step_2:size(st, <span class="number">1</span>)-step_1)</span><br><span class="line">    nblocks = ceil(<span class="built_in">Int</span>, N/<span class="number">256</span>)</span><br><span class="line">    <span class="meta">@cuda</span> threads=<span class="number">256</span> blocks=nblocks kernel(st)</span><br><span class="line">    <span class="keyword">return</span> st</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="Benchmark"><a href="#Benchmark" class="headerlink" title="Benchmark"></a>Benchmark</h2><p>Now let’s see how fast is our ~600 line of code quantum circuit emulator. I don’t intend to go through a complete benchmark here<br>since the above implementation is generic it will has similar benchmark on different kinds of gates. And there are still plenty<br>of room to optimize, e.g we can specialize each routine for a known gate, such <code>X</code> gate, <code>H</code> gate to make use of their matrix structure.</p>
<p>The benchmark of multi-threaded routines and CUDA is currently missing since I don’t have access to a<br>GPU with <code>ComplexF64</code> support to make the comparison fair. However, this blog post is a simple version of<br><a target="_blank" rel="noopener" href="https://github.com/QuantumBFS/YaoArrayRegister.jl">YaoArrayRegister</a><br>in the <a target="_blank" rel="noopener" href="https://yaoquantum.org/">Yao</a> ecosystem, you can use the benchmark of Yao for reference. Or please also feel free to<br>benchmark the implementation and play with it in this blog post yourself for sure!</p>
<p>Let me compare this with one of the current best performance simulator <a target="_blank" rel="noopener" href="https://github.com/qulacs/qulacs">qulacs</a>, you should be able<br>to find relative benchmark comparing qulacs and other software <a target="_blank" rel="noopener" href="https://github.com/Roger-luo/quantum-benchmarks/blob/release-0.1/RESULTS.md">here</a>.<br>(I’m not comparing with Yao because the implementation is similar to what is implemented in Yao.)</p>
<p>first we clone the benchmark repo</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/Roger-luo/quantum-benchmarks.git</span><br></pre></td></tr></table></figure>
<p>then checkout to the stable release branch <code>release-0.1</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> quantum-benchmarks &amp;&amp; git checkout release-0.1</span><br><span class="line">bin/benchmark setup qulacs</span><br><span class="line">bin/benchmark run qulacs</span><br></pre></td></tr></table></figure>
<p>this will prepare us the benchmark data on our machine. then we benchmark our own implementation</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> BenchmarkTools</span><br><span class="line"></span><br><span class="line">data = <span class="built_in">Dict</span>(</span><br><span class="line">    <span class="string">&quot;X&quot;</span> =&gt; [],</span><br><span class="line">    <span class="string">&quot;T&quot;</span> =&gt; [],</span><br><span class="line">    <span class="string">&quot;H&quot;</span> =&gt; [],</span><br><span class="line">    <span class="string">&quot;CNOT&quot;</span> =&gt; [],</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="number">4</span>:<span class="number">25</span></span><br><span class="line">    st = rand(<span class="built_in">ComplexF64</span>, <span class="number">1</span>&lt;&lt;n)</span><br><span class="line">    t = <span class="meta">@benchmark</span> broutine!(r, $([<span class="number">0</span> <span class="number">1</span>;<span class="number">1</span> <span class="number">0</span>]), (<span class="number">3</span>, )) setup=(r=copy($st))</span><br><span class="line">    push!(data[<span class="string">&quot;X&quot;</span>], minimum(t).time)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="number">4</span>:<span class="number">25</span></span><br><span class="line">    st = rand(<span class="built_in">ComplexF64</span>, <span class="number">1</span>&lt;&lt;n)</span><br><span class="line">    t = <span class="meta">@benchmark</span> broutine!(r, $([<span class="number">1</span> <span class="number">0</span>;<span class="number">0</span> exp(<span class="literal">im</span> * <span class="literal">π</span> / <span class="number">4</span>)]), (<span class="number">3</span>, )) setup=(r=copy($st))</span><br><span class="line">    push!(data[<span class="string">&quot;T&quot;</span>], minimum(t).time)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="number">4</span>:<span class="number">25</span></span><br><span class="line">    st = rand(<span class="built_in">ComplexF64</span>, <span class="number">1</span>&lt;&lt;n)</span><br><span class="line">    t = <span class="meta">@benchmark</span> broutine!(r, $([<span class="number">1</span>/sqrt(<span class="number">2</span>) <span class="number">1</span>/sqrt(<span class="number">2</span>); <span class="number">1</span>/sqrt(<span class="number">2</span>) -<span class="number">1</span>/sqrt(<span class="number">2</span>)]), (<span class="number">3</span>, )) setup=(r=copy($st))</span><br><span class="line">    push!(data[<span class="string">&quot;H&quot;</span>], minimum(t).time)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="number">4</span>:<span class="number">25</span></span><br><span class="line">    st = rand(<span class="built_in">ComplexF64</span>, <span class="number">1</span>&lt;&lt;n)</span><br><span class="line">    t = <span class="meta">@benchmark</span> broutine!(r, $([<span class="number">0</span> <span class="number">1</span>;<span class="number">1</span> <span class="number">0</span>]), (<span class="number">2</span>, ), (<span class="number">3</span>, ), (<span class="number">1</span>, )) setup=(r=copy($st))</span><br><span class="line">    push!(data[<span class="string">&quot;X&quot;</span>], minimum(t).time)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><em>note: we always use minimum time as a stable estimator for benchmarks</em></p>
<p>now we plot the benchmark of <code>X</code>, <code>H</code>, <code>T</code>, <code>CNOT</code>.</p>
<p><img src="/images/implement-your-own-qc-simulator/benchmark.png" alt="benchmark"></p>
<h2 id="What’s-more"><a href="#What’s-more" class="headerlink" title="What’s more?"></a>What’s more?</h2><p>Recall our previous implementation, since we didn’t specify our matrix type or vector type<br>to be a <code>Vector</code> or other concrete type, and didn’t specify the element type has to be a <code>ComplexF64</code> either,<br>this means ANY subtype of <code>AbstractVector</code>, and ANY subtype of <code>Number</code> can be used with the above methods.<br>Now we can do something interesting, e.g we can automatically get the ability of symbolic calculation by<br>feeding symbolic number type from <code>SymEngine</code> package or <code>SymbolicUtils</code> package.<br>Or we can use <code>Dual</code> number to perform forward mode differentiation directly. Or we can estimate error<br>by using the error numbers from <code>Measurements</code>.</p>
<p>Here is demo of using <code>SymEngine</code>:</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> SymEngine</span><br><span class="line"></span><br><span class="line">julia&gt; <span class="meta">@vars</span> α θ</span><br><span class="line">(α, θ)</span><br><span class="line"></span><br><span class="line">julia&gt; st = Basic[<span class="number">1</span>, α, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"><span class="number">4</span>-element <span class="built_in">Array</span>&#123;Basic,<span class="number">1</span>&#125;:</span><br><span class="line"> <span class="number">1</span></span><br><span class="line"> α</span><br><span class="line"> <span class="number">0</span></span><br><span class="line"> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">julia&gt; broutine!(st, [exp(-<span class="literal">im</span> * θ) <span class="number">0</span>; <span class="number">0</span> exp(<span class="literal">im</span> * θ)], (<span class="number">1</span>, ))</span><br><span class="line"><span class="number">4</span>-element <span class="built_in">Array</span>&#123;Basic,<span class="number">1</span>&#125;:</span><br><span class="line">  exp(-<span class="literal">im</span>*θ)</span><br><span class="line"> exp(<span class="literal">im</span>*θ)*α</span><br><span class="line">           <span class="number">0</span></span><br><span class="line">           <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>This is only possible when one is able to use <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Generic_programming">generic programming</a> to write<br>high performance program, which is usually not possible in the two-language solution Python/C++ without implementing one’s own<br>type system and domain specific language (DSL) compiler, which eventually becomes some efforts that reinventing the wheels.</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Getting similar performance or beyond comparing to Python/C++ solution in numerical computation<br>is easily achievable in pure Julia with much less code. Although, we should wrap some of the overlapping<br>code into functions and call them as a better practice, we still only use less than 600 lines of code<br>with copy pasting everywhere. </p>
<p>Moreover, the power of generic programming<br>will unleash our thinking of numerical methods on many different numerical types.</p>
<p>Experienced readers may find there may still rooms for further optimization, e.g we didn’t specialize<br>much common gates yet, and the loop unroll size might not be the perfect size, and may still vary due<br>to the machine.</p>
<p>Last, besides simulating quantum circuits, the above implementation of subspace matrix multiplication<br>is actually a quite common routine happens frequently in <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Tensor_contraction">tensor contraction</a><br>(because quantum circuits are one kind of tensor network), thus more promising application can be using these routines for tensor<br>contraction, however, to make these type of operations more efficient, it may require us to implement BLAS level 3 operation in the subspace<br>which is the subspace matrix-matrix multiplication, which can require more tricks and more interesting.</p>
<hr>
<p>I uploaded the implementation as a gist: <a target="_blank" rel="noopener" href="https://gist.github.com/Roger-luo/0df73cabf4c91f9854657fdd2ed66767">https://gist.github.com/Roger-luo/0df73cabf4c91f9854657fdd2ed66767</a></p>

    </div>

    
    
    
        

  <div class="followme">
    <p>Welcome to my other publishing channels</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="https://twitter.com/rogerluorl18">
            <span class="icon">
              <i class="fab fa-twitter"></i>
            </span>

            <span class="label">Twitter</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/quantum-computing/" rel="tag"># quantum-computing</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/07/27/yassad/" rel="prev" title="Implement Your Own Source To Source AD in ONE day!">
      <i class="fa fa-chevron-left"></i> Implement Your Own Source To Source AD in ONE day!
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Background"><span class="nav-number">1.</span> <span class="nav-text">Background</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Implementing-general-unitary-gate"><span class="nav-number">2.</span> <span class="nav-text">Implementing general unitary gate</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Iterate-through-the-subspace"><span class="nav-number">2.1.</span> <span class="nav-text">Iterate through the subspace</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Multiply-matrix-in-subspace"><span class="nav-number">2.2.</span> <span class="nav-text">Multiply matrix in subspace</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Implement-controlled-gate"><span class="nav-number">3.</span> <span class="nav-text">Implement controlled gate</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#General-controlled-unitary-gate"><span class="nav-number">3.1.</span> <span class="nav-text">General controlled unitary gate</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Optimize-performance-for-small-matrices"><span class="nav-number">4.</span> <span class="nav-text">Optimize performance for small matrices</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Parallelize-using-Multi-threads"><span class="nav-number">5.</span> <span class="nav-text">Parallelize using Multi-threads</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Parallelize-using-CUDA"><span class="nav-number">6.</span> <span class="nav-text">Parallelize using CUDA</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Benchmark"><span class="nav-number">7.</span> <span class="nav-text">Benchmark</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#What%E2%80%99s-more"><span class="nav-number">8.</span> <span class="nav-text">What’s more?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Conclusion"><span class="nav-number">9.</span> <span class="nav-text">Conclusion</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Xiu-Zhe (Roger) Luo</p>
  <div class="site-description" itemprop="description">Where I writes about Machine Learning, Quanutm Physics, and more.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Roger-luo" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Roger-luo" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/rogerluorl18" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;rogerluorl18" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Xiu-Zhe (Roger) Luo</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://blog-rogerluo-me.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "http://rogerluo.me/blog/2020/03/31/yany/";
    this.page.identifier = "2020/03/31/yany/";
    this.page.title = "Build your own Top Performance Quantum Circuit Simulator in ONE DAY!";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://blog-rogerluo-me.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
