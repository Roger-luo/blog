<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rogerluo.me","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Where I writes about Machine Learning, Quanutm Physics, and more.">
<meta property="og:type" content="website">
<meta property="og:title" content="Half Integer">
<meta property="og:url" content="http://rogerluo.me/blog/index.html">
<meta property="og:site_name" content="Half Integer">
<meta property="og:description" content="Where I writes about Machine Learning, Quanutm Physics, and more.">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Xiu-Zhe (Roger) Luo">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://rogerluo.me/blog/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Half Integer</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Half Integer</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Xiu-Zhe (Roger) Luo's Blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rogerluo.me/blog/2020/03/31/yany/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xiu-Zhe (Roger) Luo">
      <meta itemprop="description" content="Where I writes about Machine Learning, Quanutm Physics, and more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Half Integer">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/31/yany/" class="post-title-link" itemprop="url">Build your own Top Performance Quantum Circuit Simulator in ONE DAY!</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-31 01:22:18" itemprop="dateCreated datePublished" datetime="2020-03-31T01:22:18-04:00">2020-03-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-21 11:00:38" itemprop="dateModified" datetime="2020-12-21T11:00:38-05:00">2020-12-21</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2020/03/31/yany/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/03/31/yany/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>How hard is it to build your own top performance quantum circuit simulator? Does it really needs thousands of lines of code to implement it?<br>At least in Julia language, you don’t! We can easily achieve top performance via a few hundreds of code while supporting<br>CUDA and symbolic calculation.</p>
<p>Like my previous blog posts, you can do it in ONE DAY as well. I’ll introduce how to do this with Julia language while going<br>through some common tricks for high performance computing in Julia language. I won’t talk much about the Julia language itself<br>or it will be a very long blog post, thus if you want to follow this blog post but you don’t know how to use the Julia programming<br>language yet, I would suggest you to checkout materials <a target="_blank" rel="noopener" href="https://julialang.org/learning/">here</a> first.</p>
<h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Quantum_computing">Quantum computing</a> has been a popular research topic in recent years. And building simulators can be useful for related research. I’m not going to give you a full introduction of what is quantum computing in this blog post, but I find you <a target="_blank" rel="noopener" href="https://youtu.be/F_Riqjdh2oM">this nice tutorial from Microsoft</a> if you are<br>really interested in knowing what is the quantum computing. And you don’t really need to understand everything about quantum computing to follow this blog post - the emulator itself is just about special matrix-vector or matrix-matrix multiplication.</p>
<p>So to be simple, simulating quantum circuits, or to be more specific simulating how quantum circuits act on a quantum register, is about how to calculate large matrix-vector multiplication that scales exponentially. The vector contains the so-called quantum state and the matrices are quantum gate, which are usually small. The diagram of quantum circuits is a representation of these matrix multiplications. </p>
<p>For example, the X gate is just a small matrix</p>
<p>$$<br>\begin{pmatrix}<br>0 &amp; 1\\<br>1 &amp; 0<br>\end{pmatrix}<br>$$ </p>
<p>In theory, there is no way to simulate a general quantum circuit (more precisely, a universal gate set) efficiently, however, in practice, we could still do it within a rather small scale with some tricks that make use of the structure of the gates.</p>
<p>To know how to calculate a quantum circuit in the most naive way, we need to know two kinds of mathematical operations</p>
<p><strong>Tensor Product/Kronecker Product</strong>, this is represented as two parallel lines in the quantum circuit diagram, e.g</p>
<p><img src="/images/implement-your-own-qc-simulator/kron-X-X.png" alt="kron(X, X)"></p>
<p>and by definition, this can be calculated by</p>
<p>$$<br>\begin{pmatrix}<br>a_{11} &amp; a_{12} \\<br>a_{21} &amp; a_{22}<br>\end{pmatrix} \otimes<br>\begin{pmatrix}<br>b_{11} &amp; b_{12} \\<br>b_{21} &amp; b_{22}<br>\end{pmatrix} =<br>\begin{pmatrix}<br>a_{11} \begin{pmatrix}<br>b_{11} &amp; b_{12} \\<br>b_{21} &amp; b_{22}<br>\end{pmatrix} &amp; a_{12} \begin{pmatrix}<br>b_{11} &amp; b_{12} \\<br>b_{21} &amp; b_{22}<br>\end{pmatrix} \\<br>a_{21} \begin{pmatrix}<br>b_{11} &amp; b_{12} \\<br>b_{21} &amp; b_{22}<br>\end{pmatrix} &amp; a_{22} \begin{pmatrix}<br>b_{11} &amp; b_{12} \\<br>b_{21} &amp; b_{22}<br>\end{pmatrix}<br>\end{pmatrix}<br>$$</p>
<p><strong>Matrix Multiplication</strong>, this is the most basic linear algebra operation, I’ll skip introducing this. In quantum circuit diagram, this is represented by blocks connected by lines.</p>
<p><img src="/images/implement-your-own-qc-simulator/chain-X-X.png" alt="X-X"></p>
<p>As a conclusion of this section, you can see simulating how pure quantum circuits act on a given quantum state is about how to implement some special type of matrix-vector multiplication<br>efficiently. If you know about BLAS (Basic Linear Algebra Subprograms), you will realize this kind of operations are only BLAS level 2 operations, which does not require any smart tiling<br>technique and are mainly limited by memory bandwidth.</p>
<p>So let’s do it!</p>
<h2 id="Implementing-general-unitary-gate"><a href="#Implementing-general-unitary-gate" class="headerlink" title="Implementing general unitary gate"></a>Implementing general unitary gate</h2><p>Thus the simplest way of simulating a quantum circuit is very straightforward: we can just make use of Julia’s builtin functions:<br><code>kron</code> and <code>*</code>.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> LinearAlgebra</span><br><span class="line"><span class="keyword">function</span> naive_broutine!(r::<span class="built_in">AbstractVector</span>, U::<span class="built_in">AbstractMatrix</span>, loc::<span class="built_in">Int</span>)</span><br><span class="line">    n = <span class="built_in">Int</span>(log2(length(r))) <span class="comment"># get the number of qubits</span></span><br><span class="line">    <span class="keyword">return</span> kron(I(<span class="number">1</span>&lt;&lt;(n-loc+<span class="number">1</span>)), U), I(<span class="number">1</span>&lt;&lt;loc)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>However, this is obviously very inefficient: </p>
<ol>
<li>we need to allocate a $2^n \times 2^n$ matrix every time we try to evaluate the gate.</li>
<li>the length of the vector can only be $2^n$, thus we should be able to calculate it faster with this knowledge.</li>
</ol>
<hr>
<p>I’ll start from the easiest thing: if we know an integer is $2^n$, it is straight forward to find out $n$ by the following method</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">log2i(x::<span class="built_in">Int64</span>) = !signbit(x) ? (<span class="number">63</span> - leading_zeros(x)) : throw(<span class="built_in">ErrorException</span>(<span class="string">&quot;nonnegative expected (<span class="variable">$x</span>)&quot;</span>))</span><br><span class="line">log2i(x::<span class="built_in">UInt64</span>) = <span class="number">63</span> - leading_zeros(x)</span><br></pre></td></tr></table></figure>
<p>this is because we already know how long our integer is in the program by looking at its type, thus simply minus the number of leading zeros would give us the answer.<br>But don’t forget to raise an error when it’s an signed integer type. We can make this work on any integer type by the following way</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> N <span class="keyword">in</span> [<span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>]</span><br><span class="line">    T = <span class="built_in">Symbol</span>(:<span class="built_in">Int</span>, N)</span><br><span class="line">    UT = <span class="built_in">Symbol</span>(:<span class="built_in">UInt</span>, N)</span><br><span class="line">    <span class="meta">@eval</span> <span class="keyword">begin</span></span><br><span class="line">        log2i(x::$T) =</span><br><span class="line">            !signbit(x) ? ($(N - <span class="number">1</span>) - leading_zeros(x)) :</span><br><span class="line">            throw(<span class="built_in">ErrorException</span>(<span class="string">&quot;nonnegative expected (<span class="variable">$x</span>)&quot;</span>))</span><br><span class="line">        log2i(x::$UT) = $(N - <span class="number">1</span>) - leading_zeros(x)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>the command <code>@eval</code> here is called a macro in Julia programming language, it can be used to generate code. The above code generates the implementation of <code>log2i</code> for signed<br>and unsigned integer types from 8 bits to 128 bits.</p>
<hr>
<p>Let’s now consider how to write the general unitary gate acting on given locations of qubits.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> broutine!(r::<span class="built_in">AbstractVector</span>, U::<span class="built_in">AbstractMatrix</span>, locs::<span class="built_in">NTuple</span>&#123;N, <span class="built_in">Int</span>&#125;) <span class="keyword">where</span> N</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>this matrix will act on some certain qubits in the register, e.g given a 8x8 matrix we want it to act on the 1st, 4th and 5th qubit. Based on the implementation of X and Z we know this is about multiplying this matrix on the subspace of 1st, 4th and 5th qubit, which means we need to construct a set of new vectors whose indices iterate over the subspace of <code>0xx00x</code>, <code>0xx01x</code>, <code>0xx10x</code>, <code>0xx11x</code> etc. Thus the first thing we need to do is to find a generic way to iterate through the subspace of <code>0xx00x</code> then by adding an offset such as <code>1&lt;&lt;1</code> to each index in this subspace, we can get the subspace of <code>0xx01x</code> etc.</p>
<h3 id="Iterate-through-the-subspace"><a href="#Iterate-through-the-subspace" class="headerlink" title="Iterate through the subspace"></a>Iterate through the subspace</h3><p>To iterate through the subspace, we could iterate through all indices in the subspace. For each index, we move each bit to its position in the whole space (from first bit to the last).<br>This will give us the first subspace which is <code>0xx00x</code>.</p>
<hr>
<p>Before we move on, I need to introduce the concept of binary masks: it is an integer that can help us “filter” out some binary values, e.g<br>we want to know if a given integer’s 4th and 5th bit, we can use a mask <code>0b11000</code>, where its 4th and 5th bit are <code>1</code> the rest is <code>0</code>, then we<br>can use an and operation get get the value. Given the location of bits, we can create a binary mask via the following <code>bmask</code> function</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> bmask(itr)</span><br><span class="line">    isempty(itr) &amp;&amp; <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    ret = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> b <span class="keyword">in</span> itr</span><br><span class="line">        ret += <span class="number">1</span> &lt;&lt; (b - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>where <code>itr</code> is some iterable. However there are quite a few cases that we don’t need to create it via a for-loop, so we can specialize this function<br>on the following types</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> bmask(range::<span class="built_in">UnitRange</span>&#123;<span class="built_in">Int</span>&#125;)</span><br><span class="line">    ((<span class="number">1</span> &lt;&lt; (range.stop - range.start + <span class="number">1</span>)) - <span class="number">1</span>) &lt;&lt; (range.start - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>however, we maybe want to make the implementation more general for arbitrary integer types, so let’s use a type variable <code>T</code>!</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> bmask(::<span class="built_in">Type</span>&#123;T&#125;, itr) <span class="keyword">where</span> &#123;T&lt;:<span class="built_in">Integer</span>&#125;</span><br><span class="line">    isempty(itr) &amp;&amp; <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    ret = zero(T)</span><br><span class="line">    <span class="keyword">for</span> b <span class="keyword">in</span> itr</span><br><span class="line">        ret += one(T) &lt;&lt; (b - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> bmask(::<span class="built_in">Type</span>&#123;T&#125;, range::<span class="built_in">UnitRange</span>&#123;<span class="built_in">Int</span>&#125;)::T <span class="keyword">where</span> &#123;T&lt;:<span class="built_in">Integer</span>&#125;</span><br><span class="line">    ((one(T) &lt;&lt; (range.stop - range.start + <span class="number">1</span>)) - one(T)) &lt;&lt; (range.start - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>However after we put a type variable as the first argument, it is not convenient when we just want to use <code>Int64</code> anymore,<br>let’s create a few convenient methods then</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bmask(args...) = bmask(<span class="built_in">Int</span>, args...)</span><br><span class="line"><span class="comment"># this is for removing the infinity call of the later function</span></span><br><span class="line">bmask(::<span class="built_in">Type</span>&#123;T&#125;) <span class="keyword">where</span> &#123;T&lt;:<span class="built_in">Integer</span>&#125; = zero(T)</span><br><span class="line">bmask(::<span class="built_in">Type</span>&#123;T&#125;, positions::<span class="built_in">Int</span>...) <span class="keyword">where</span> &#123;T&lt;:<span class="built_in">Integer</span>&#125; = bmask(T, positions)</span><br></pre></td></tr></table></figure>
<p>The final implement would look like the following</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">bmask(args...) = bmask(<span class="built_in">Int</span>, args...)</span><br><span class="line">bmask(::<span class="built_in">Type</span>&#123;T&#125;) <span class="keyword">where</span> &#123;T&lt;:<span class="built_in">Integer</span>&#125; = zero(T)</span><br><span class="line">bmask(::<span class="built_in">Type</span>&#123;T&#125;, positions::<span class="built_in">Int</span>...) <span class="keyword">where</span> &#123;T&lt;:<span class="built_in">Integer</span>&#125; = bmask(T, positions)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> bmask(::<span class="built_in">Type</span>&#123;T&#125;, itr) <span class="keyword">where</span> &#123;T&lt;:<span class="built_in">Integer</span>&#125;</span><br><span class="line">    isempty(itr) &amp;&amp; <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    ret = zero(T)</span><br><span class="line">    <span class="keyword">for</span> b <span class="keyword">in</span> itr</span><br><span class="line">        ret += one(T) &lt;&lt; (b - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> bmask(::<span class="built_in">Type</span>&#123;T&#125;, range::<span class="built_in">UnitRange</span>&#123;<span class="built_in">Int</span>&#125;)::T <span class="keyword">where</span> &#123;T&lt;:<span class="built_in">Integer</span>&#125;</span><br><span class="line">    ((one(T) &lt;&lt; (range.stop - range.start + <span class="number">1</span>)) - one(T)) &lt;&lt; (range.start - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<hr>
<p>To move the bits in subspace to the right position, we need to iterate through all the contiguous region in the bitstring, e.g for <code>0xx00x</code>, we<br>move the 2nd and 3rd bit in subspace by 3 bits together, this can be achieved by using a bit mask <code>001</code> and the following binary operation</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(xxx &amp; ~<span class="number">0b001</span>) &lt;&lt; <span class="number">1</span> + (xxx &amp; <span class="number">0b001</span>) <span class="comment"># = xx00x</span></span><br></pre></td></tr></table></figure>
<p>we define this as a function called <code>lmove</code>:</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@inline</span> lmove(b::<span class="built_in">Int</span>, mask::<span class="built_in">Int</span>, k::<span class="built_in">Int</span>)::<span class="built_in">Int</span> = (b &amp; ~mask) &lt;&lt; k + (b &amp; mask)</span><br></pre></td></tr></table></figure>
<p>we mark this function <code>@inline</code> here to make sure the compiler will always inline it,<br>now we need to generate all the masks by counting contiguous region of the given locations</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> group_shift(locations)</span><br><span class="line">    masks = <span class="built_in">Int</span>[]</span><br><span class="line">    region_lens = <span class="built_in">Int</span>[]</span><br><span class="line">    k_prv = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> locations</span><br><span class="line">        <span class="comment"># if current position in the contiguous region</span></span><br><span class="line">        <span class="comment"># since these bits will be moved together with</span></span><br><span class="line">        <span class="comment"># the first one, we don&#x27;t need to generate a</span></span><br><span class="line">        <span class="comment"># new mask</span></span><br><span class="line">        <span class="keyword">if</span> k == k_prv + <span class="number">1</span></span><br><span class="line">            region_lens[<span class="keyword">end</span>] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment"># we generate a bit mask where the 1st to k-th bits are 1</span></span><br><span class="line">            push!(masks, bmask(<span class="number">0</span>:k-<span class="number">1</span>))</span><br><span class="line">            push!(region_lens, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        k_prv = k</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> masks, region_lens</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>now to get the index in the whole space, we simply move each contiguous region by the length of their region,</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> <span class="number">1</span>:n_regions</span><br><span class="line">    index = lmove(index, masks[s], region_lens[s])</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>where the initial value of <code>index</code> is the subspace index, and after the loop, we will get the index in the whole space.</p>
<p>Now, since we need to iterate the all the possible indices, it would be very convenient to have an iterator, let’s implement<br>this as an iterator,</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> BitSubspace</span><br><span class="line">    n::<span class="built_in">Int</span> <span class="comment"># total number of bits</span></span><br><span class="line">    n_subspace::<span class="built_in">Int</span> <span class="comment"># number of bits in the subspace</span></span><br><span class="line">    masks::<span class="built_in">Vector</span>&#123;<span class="built_in">Int</span>&#125; <span class="comment"># masks</span></span><br><span class="line">    region_lens::<span class="built_in">Vector</span>&#123;<span class="built_in">Int</span>&#125; <span class="comment"># length of each region</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>and we can construct it via</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> BitSubspace(n::<span class="built_in">Int</span>, locations)</span><br><span class="line">    masks, region_lens = group_shift(locations)</span><br><span class="line">    BitSubspace(<span class="number">1</span> &lt;&lt; (n - length(locations)), length(masks), masks, region_lens)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>now, let’s consider the corresponding whole-space index of each index in the subspace.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@inline</span> <span class="keyword">function</span> Base.getindex(it::BitSubspace, i)</span><br><span class="line">    index = i - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> <span class="number">1</span>:it.n_subspace</span><br><span class="line">        <span class="meta">@inbounds</span> index = lmove(index, it.masks[s], it.region_lens[s])</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> index</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>now let’s overload some methods to make this object become an iterable object</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Base.length(it::BitSubspace) = it.n</span><br><span class="line">Base.eltype(::BitSubspace) = <span class="built_in">Int</span></span><br><span class="line"><span class="meta">@inline</span> <span class="keyword">function</span> Base.iterate(it::BitSubspace, st = <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> st &gt; length(it)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nothing</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> it[st], st + <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>let’s try it! it works!</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; <span class="keyword">for</span> each <span class="keyword">in</span> BitSubspace(<span class="number">5</span>, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">            println(string(each, base=<span class="number">2</span>, pad=<span class="number">7</span>))</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line"><span class="number">00000</span></span><br><span class="line"><span class="number">00010</span></span><br><span class="line"><span class="number">10000</span></span><br><span class="line"><span class="number">10010</span></span><br></pre></td></tr></table></figure>
<h3 id="Multiply-matrix-in-subspace"><a href="#Multiply-matrix-in-subspace" class="headerlink" title="Multiply matrix in subspace"></a>Multiply matrix in subspace</h3><p>now we know how to generate the indices in a subspace, we need to multiply the matrix to each subspace,<br>e.g for a unitary on the 1, 3, 4 qubits of a 5-qubit register, we need to multiply the matrix at <code>0xx0x</code>,<br><code>0xx1x</code>, <code>1xx0x</code> and <code>1xx1x</code>. Thus we can create the subspace of <code>x00x0</code> by <code>BitSubspace(5, [1, 3, 4])</code><br>and subspace of <code>0xx0x</code> by <code>BitSubspace(5, [2, 5])</code>, then add each index in <code>x00x0</code> to <code>0xx0x</code>, which looks like</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">subspace1 = BitSubspace(<span class="number">5</span>, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">subspace2 = BitSubspace(<span class="number">5</span>, [<span class="number">2</span>, <span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Julia uses 1-based index, we need to convert it</span></span><br><span class="line">indices = collect(b + <span class="number">1</span> <span class="keyword">for</span> b <span class="keyword">in</span> subspace2)</span><br><span class="line"></span><br><span class="line"><span class="meta">@inbounds</span> <span class="keyword">for</span> i <span class="keyword">in</span> subspace1</span><br><span class="line">    <span class="comment"># add an offset i to all the indices of 0xx0x</span></span><br><span class="line">    <span class="comment"># this will give us 0xx0x, 0xx1x, 1xx0x, 1xx1x</span></span><br><span class="line">    idx = indices .+ i</span><br><span class="line">    state[idx] = U * state[idx] <span class="comment"># matrix multiplication on the subspace</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>now we notice <code>subspace2</code> is the complement subspace of <code>subspace1</code> because the full space if <code>[1, 2, 3, 4, 5]</code>, so let’s redefine our <code>BitSubspace</code><br>constructor a bit, now instead of define the constructor <code>BitSubspace(n, locations)</code> we define two functions to create this object <code>bsubspace(n, locations)</code> and<br><code>bcomspace(n, locations)</code> which stands for <em>binary subspace</em> and <em>binary complement space</em>, the function <code>bsubspace</code> will create <code>subspace1</code> and the function<br><code>bcomspace(n, locations)</code> will create <code>subspace2</code>.</p>
<p>They have some overlapping operations, so I move them to an internal function <code>_group_shift</code></p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@inline</span> <span class="keyword">function</span> group_shift(locations)</span><br><span class="line">    masks = <span class="built_in">Int</span>[]</span><br><span class="line">    shift_len = <span class="built_in">Int</span>[]</span><br><span class="line">    k_prv = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> locations</span><br><span class="line">        _group_shift(masks, shift_len, k, k_prv)</span><br><span class="line">        k_prv = k</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> masks, shift_len</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@inline</span> <span class="keyword">function</span> complement_group_shift(n::<span class="built_in">Int</span>, locations)</span><br><span class="line">    masks = <span class="built_in">Int</span>[]</span><br><span class="line">    shift_len = <span class="built_in">Int</span>[]</span><br><span class="line">    k_prv = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="number">1</span>:n</span><br><span class="line">        k <span class="keyword">in</span> locations &amp;&amp; <span class="keyword">continue</span></span><br><span class="line">        _group_shift(masks, shift_len, k, k_prv)</span><br><span class="line">        k_prv = k</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> masks, shift_len</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@inline</span> <span class="keyword">function</span> _group_shift(masks::<span class="built_in">Vector</span>&#123;<span class="built_in">Int</span>&#125;, shift_len::<span class="built_in">Vector</span>&#123;<span class="built_in">Int</span>&#125;, k::<span class="built_in">Int</span>, k_prv::<span class="built_in">Int</span>)</span><br><span class="line">    <span class="comment"># if current position in the contiguous region</span></span><br><span class="line">    <span class="comment"># since these bits will be moved together with</span></span><br><span class="line">    <span class="comment"># the first one, we don&#x27;t need to generate a</span></span><br><span class="line">    <span class="comment"># new mask</span></span><br><span class="line">    <span class="keyword">if</span> k == k_prv + <span class="number">1</span></span><br><span class="line">        shift_len[<span class="keyword">end</span>] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment"># we generate a bit mask where the 1st to k-th bits are 1</span></span><br><span class="line">        push!(masks, bmask(<span class="number">0</span>:k-<span class="number">1</span>))</span><br><span class="line">        push!(shift_len, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>thus our routine will look like the following</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> broutine!(st::<span class="built_in">AbstractVector</span>, U::<span class="built_in">AbstractMatrix</span>, locs::<span class="built_in">NTuple</span>&#123;N, <span class="built_in">Int</span>&#125;) <span class="keyword">where</span> N</span><br><span class="line">    n = log2dim1(st)</span><br><span class="line">    subspace = bsubspace(n, locs)</span><br><span class="line">    comspace = bcomspace(n, locs)</span><br><span class="line">    indices = [idx + <span class="number">1</span> <span class="keyword">for</span> idx <span class="keyword">in</span> comspace]</span><br><span class="line">    <span class="meta">@inbounds</span> <span class="meta">@views</span> <span class="keyword">for</span> k <span class="keyword">in</span> subspace</span><br><span class="line">        idx = indices .+ k</span><br><span class="line">        st[idx] = U * st[idx]</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> st</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>the <code>log2dim1</code> is just a convenient one-liner <code>log2dim1(x) = log2i(size(x, 1))</code>. And we use <code>@inbounds</code> here to tell the Julia compiler<br>that we are pretty sure all our indices are inbounds! And use <code>@views</code> to tell Julia we are confident at mutating our arrays so please<br>use a <code>view</code> and don’t allocate any memory!</p>
<p>Now you may notice: the iteration in our implementation is independent and may be reordered! This means we can easily make this parallel. The simplest way to parallelize it is via multi-threading. In Julia, this is extremely simple,</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> threaded_broutine!(st::<span class="built_in">AbstractVector</span>, U::<span class="built_in">AbstractMatrix</span>, locs::<span class="built_in">NTuple</span>&#123;N, <span class="built_in">Int</span>&#125;) <span class="keyword">where</span> N</span><br><span class="line">    n = log2dim1(st)</span><br><span class="line">    subspace = bsubspace(n, locs)</span><br><span class="line">    comspace = bcomspace(n, locs)</span><br><span class="line">    indices = [idx + <span class="number">1</span> <span class="keyword">for</span> idx <span class="keyword">in</span> comspace]</span><br><span class="line">    <span class="meta">@inbounds</span> <span class="meta">@views</span> Threads.<span class="meta">@threads</span> <span class="keyword">for</span> k <span class="keyword">in</span> subspace</span><br><span class="line">        idx = indices .+ k</span><br><span class="line">        st[idx] = U * st[idx]</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> st</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>but wait, this will give you en error <code>MethodError: no method matching firstindex(::BitSubspace)</code>, this is simply because<br>the <code>@threads</code> wants calculate which indices it needs to put into one thread using <code>firstindex</code>, so let’s define it</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base.firstindex(::BitSubspace) = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>thus the final implementation of subspace would looks like the following</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@inline</span> <span class="keyword">function</span> _group_shift(masks::<span class="built_in">Vector</span>&#123;<span class="built_in">Int</span>&#125;, shift_len::<span class="built_in">Vector</span>&#123;<span class="built_in">Int</span>&#125;, k::<span class="built_in">Int</span>, k_prv::<span class="built_in">Int</span>)</span><br><span class="line">    <span class="comment"># if current position in the contiguous region</span></span><br><span class="line">    <span class="comment"># since these bits will be moved together with</span></span><br><span class="line">    <span class="comment"># the first one, we don&#x27;t need to generate a</span></span><br><span class="line">    <span class="comment"># new mask</span></span><br><span class="line">    <span class="keyword">if</span> k == k_prv + <span class="number">1</span></span><br><span class="line">        shift_len[<span class="keyword">end</span>] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment"># we generate a bit mask where the 1st to k-th bits are 1</span></span><br><span class="line">        push!(masks, bmask(<span class="number">0</span>:k-<span class="number">1</span>))</span><br><span class="line">        push!(shift_len, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@inline</span> <span class="keyword">function</span> group_shift(locations)</span><br><span class="line">    masks = <span class="built_in">Int</span>[]</span><br><span class="line">    shift_len = <span class="built_in">Int</span>[]</span><br><span class="line">    k_prv = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> locations</span><br><span class="line">        _group_shift(masks, shift_len, k, k_prv)</span><br><span class="line">        k_prv = k</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> masks, shift_len</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@inline</span> <span class="keyword">function</span> complement_group_shift(n::<span class="built_in">Int</span>, locations)</span><br><span class="line">    masks = <span class="built_in">Int</span>[]</span><br><span class="line">    shift_len = <span class="built_in">Int</span>[]</span><br><span class="line">    k_prv = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="number">1</span>:n</span><br><span class="line">        k <span class="keyword">in</span> locations &amp;&amp; <span class="keyword">continue</span></span><br><span class="line">        _group_shift(masks, shift_len, k, k_prv)</span><br><span class="line">        k_prv = k</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> masks, shift_len</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> BitSubspace</span><br><span class="line">    n::<span class="built_in">Int</span> <span class="comment"># number of bits in fullspace</span></span><br><span class="line">    sz_subspace::<span class="built_in">Int</span> <span class="comment"># size of the subspace</span></span><br><span class="line">    n_shifts::<span class="built_in">Int</span> <span class="comment"># number of shifts</span></span><br><span class="line">    masks::<span class="built_in">Vector</span>&#123;<span class="built_in">Int</span>&#125; <span class="comment"># shift masks</span></span><br><span class="line">    shift_len::<span class="built_in">Vector</span>&#123;<span class="built_in">Int</span>&#125; <span class="comment"># length of each shift</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> Base.getindex(s::BitSubspace, i::<span class="built_in">Int</span>)</span><br><span class="line">    index = i - <span class="number">1</span></span><br><span class="line">    <span class="meta">@inbounds</span> <span class="keyword">for</span> k <span class="keyword">in</span> <span class="number">1</span>:s.n_shifts</span><br><span class="line">        index = lmove(index, s.masks[k], s.shift_len[k])</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> index</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">Base.firstindex(s::BitSubspace) = <span class="number">1</span></span><br><span class="line">Base.lastindex(s::BitSubspace) = s.sz_subspace</span><br><span class="line">Base.length(s::BitSubspace) = s.sz_subspace</span><br><span class="line">Base.eltype(::BitSubspace) = <span class="built_in">Int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> Base.iterate(s::BitSubspace, st::<span class="built_in">Int</span> = <span class="number">1</span>)</span><br><span class="line">    st &lt;= length(s) || <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">return</span> s[st], st + <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> bsubspace(n::<span class="built_in">Int</span>, locs)</span><br><span class="line">    <span class="meta">@assert</span> issorted(locs)</span><br><span class="line">    masks, shift_len = group_shift(locs)</span><br><span class="line">    BitSubspace(n, <span class="number">1</span> &lt;&lt; (n - length(locs)), length(masks), masks, shift_len)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> bcomspace(n::<span class="built_in">Int</span>, locs)</span><br><span class="line">    <span class="meta">@assert</span> issorted(locs)</span><br><span class="line">    masks, shift_len = complement_group_shift(n, locs)</span><br><span class="line">    BitSubspace(n, <span class="number">1</span> &lt;&lt; length(locs), length(masks), masks, shift_len)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> broutine!(st::<span class="built_in">AbstractVector</span>, U::<span class="built_in">AbstractMatrix</span>, locs::<span class="built_in">NTuple</span>&#123;N, <span class="built_in">Int</span>&#125;) <span class="keyword">where</span> N</span><br><span class="line">    n = log2dim1(st)</span><br><span class="line">    subspace = bsubspace(n, locs)</span><br><span class="line">    comspace = bcomspace(n, locs)</span><br><span class="line">    indices = [idx + <span class="number">1</span> <span class="keyword">for</span> idx <span class="keyword">in</span> comspace]</span><br><span class="line">    <span class="meta">@inbounds</span> <span class="meta">@views</span> <span class="keyword">for</span> k <span class="keyword">in</span> subspace</span><br><span class="line">        idx = indices .+ k</span><br><span class="line">        st[idx] = U * st[idx]</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> st</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>here I changed the definition of <code>struct BitSubspace</code> to store the number of bits in fullspace so that we can print it nicely</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Base.show(io::<span class="built_in">IO</span>, ::<span class="string">MIME&quot;text/plain&quot;</span>, s::BitSubspace)</span><br><span class="line">    indent = get(io, :indent, <span class="number">0</span>)</span><br><span class="line">    println(io, <span class="string">&quot; &quot;</span>^indent, s.sz_subspace, <span class="string">&quot;-element BitSubspace:&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> s.sz_subspace &lt; <span class="number">5</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="number">1</span>:s.sz_subspace</span><br><span class="line">            print(io, <span class="string">&quot; &quot;</span>^(indent+<span class="number">1</span>), string(s[k]; base=<span class="number">2</span>, pad=s.n))</span><br><span class="line">            <span class="keyword">if</span> k != s.sz_subspace</span><br><span class="line">                println(io)</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="comment"># never print more than 4 elements</span></span><br><span class="line">        println(io, <span class="string">&quot; &quot;</span>^(indent+<span class="number">1</span>), string(s[<span class="number">1</span>]; base=<span class="number">2</span>, pad=s.n))</span><br><span class="line">        println(io, <span class="string">&quot; &quot;</span>^(indent+<span class="number">1</span>), string(s[<span class="number">2</span>]; base=<span class="number">2</span>, pad=s.n))</span><br><span class="line">        println(io, <span class="string">&quot; &quot;</span>^(indent+<span class="number">1</span>), <span class="string">&quot;⋮&quot;</span>)</span><br><span class="line">        println(io, <span class="string">&quot; &quot;</span>^(indent+<span class="number">1</span>), string(s[<span class="keyword">end</span>-<span class="number">1</span>]; base=<span class="number">2</span>, pad=s.n))</span><br><span class="line">        print(io, <span class="string">&quot; &quot;</span>^(indent+<span class="number">1</span>), string(s[<span class="keyword">end</span>]; base=<span class="number">2</span>, pad=s.n))</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>let’s try it!</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; bsubspace(<span class="number">5</span>, (<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"><span class="number">8</span>-element BitSubspace:</span><br><span class="line"> <span class="number">00000</span></span><br><span class="line"> <span class="number">00001</span></span><br><span class="line"> ⋮</span><br><span class="line"> <span class="number">11000</span></span><br><span class="line"> <span class="number">11001</span></span><br><span class="line"></span><br><span class="line">julia&gt; bcomspace(<span class="number">5</span>, (<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"><span class="number">4</span>-element BitSubspace:</span><br><span class="line"> <span class="number">00000</span></span><br><span class="line"> <span class="number">00010</span></span><br><span class="line"> <span class="number">00100</span></span><br><span class="line"> <span class="number">00110</span></span><br></pre></td></tr></table></figure>
<h2 id="Implement-controlled-gate"><a href="#Implement-controlled-gate" class="headerlink" title="Implement controlled gate"></a>Implement controlled gate</h2><p>Now I have introduced all the tricks for normal quantum gates, however, there are another important set of gates which is controlled gates.<br>There are no new tricks, but we will need to generalize the implementation above a little bit.</p>
<h3 id="General-controlled-unitary-gate"><a href="#General-controlled-unitary-gate" class="headerlink" title="General controlled unitary gate"></a>General controlled unitary gate</h3><p>Controlled unitary gate basically means when we see an index, e.g <code>010011</code>, except applying our unitary matrix on the given location (e.g <code>1</code> and <code>2</code>), we need to look<br>at the control qubit, if the control qubit is <code>0</code>, we do nothing, if the control qubit is <code>1</code> we apply the matrix. (for inverse control gate, this is opposite)<br>Thus, this means the subspace we will be looking at contains 2 parts: the bits on control locations are <code>1</code> and the bits on gate locations are <code>0</code>. We can define our<br>offset as following:</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl_offset(locs, configs) = bmask(locs[i] <span class="keyword">for</span> (i, u) <span class="keyword">in</span> enumerate(configs) <span class="keyword">if</span> u != <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>and the corresponding routine becomes</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> routine!(st::<span class="built_in">AbstractVector</span>, U::<span class="built_in">AbstractMatrix</span>, locs::<span class="built_in">NTuple</span>&#123;N, <span class="built_in">Int</span>&#125;, ctrl_locs::<span class="built_in">NTuple</span>&#123;M, <span class="built_in">Int</span>&#125;, ctrl_configs::<span class="built_in">NTuple</span>&#123;M, <span class="built_in">Int</span>&#125;) <span class="keyword">where</span> &#123;N, M&#125;</span><br><span class="line">    n = log2dim1(st)</span><br><span class="line">    subspace = bsubspace(n, sort([locs..., ctrl_locs...]))</span><br><span class="line">    comspace = bcomspace(n, locs)</span><br><span class="line">    offset = ctrl_offset(ctrl_locs, ctrl_configs)</span><br><span class="line">    indices = [idx + <span class="number">1</span> <span class="keyword">for</span> idx <span class="keyword">in</span> comspace]</span><br><span class="line">    <span class="meta">@inbounds</span> <span class="meta">@views</span> <span class="keyword">for</span> k <span class="keyword">in</span> subspace</span><br><span class="line">        idx = indices .+ k .+ offset</span><br><span class="line">        st[idx] = U * st[idx]</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> st</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="Optimize-performance-for-small-matrices"><a href="#Optimize-performance-for-small-matrices" class="headerlink" title="Optimize performance for small matrices"></a>Optimize performance for small matrices</h2><p>In most cases, the matrices of unitary gates we want to simulate are usually very small. They are usually of size <code>2x2</code> (1 qubit),<br><code>4x4</code> (2 qubit) or <code>8x8</code> (3 qubit). In these cases, we can consider using the <code>StaticArray</code> which is much faster than openBLAS/MKL for<br>small matrices, but we don’t need to change our <code>routine!</code> implementation, since Julia will specialize our generic functions<br>automatically:</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> BenchmarkTools, StaticArrays</span><br><span class="line">U1 = rand(<span class="built_in">ComplexF64</span>, <span class="number">8</span>, <span class="number">8</span>);</span><br><span class="line">U2 = <span class="meta">@SMatrix</span> rand(<span class="built_in">ComplexF64</span>, <span class="number">8</span>, <span class="number">8</span>);</span><br><span class="line">locs = (<span class="number">4</span>, <span class="number">9</span>, <span class="number">10</span>);</span><br><span class="line">st = rand(<span class="built_in">ComplexF64</span>, <span class="number">1</span>&lt;&lt;<span class="number">15</span>);</span><br></pre></td></tr></table></figure>
<p>and we can see the benchmark</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; <span class="meta">@benchmark</span> broutine!(r, $U1, $locs) setup=(r=copy($st))</span><br><span class="line">BenchmarkTools.Trial: </span><br><span class="line">  memory estimate:  <span class="number">1.38</span> MiB</span><br><span class="line">  allocs estimate:  <span class="number">8201</span></span><br><span class="line">  --------------</span><br><span class="line">  minimum time:     <span class="number">489.581</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  median time:      <span class="number">513.550</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  mean time:        <span class="number">539.640</span> μs (<span class="number">4.09</span>% GC)</span><br><span class="line">  maximum time:     <span class="number">1.403</span> ms (<span class="number">62.67</span>% GC)</span><br><span class="line">  --------------</span><br><span class="line">  samples:          <span class="number">8451</span></span><br><span class="line">  evals/sample:     <span class="number">1</span></span><br><span class="line"></span><br><span class="line">julia&gt; <span class="meta">@benchmark</span> broutine!(r, $U2, $locs) setup=(r=copy($st))</span><br><span class="line">BenchmarkTools.Trial: </span><br><span class="line">  memory estimate:  <span class="number">576.64</span> KiB</span><br><span class="line">  allocs estimate:  <span class="number">4105</span></span><br><span class="line">  --------------</span><br><span class="line">  minimum time:     <span class="number">182.967</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  median time:      <span class="number">188.346</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  mean time:        <span class="number">202.701</span> μs (<span class="number">6.45</span>% GC)</span><br><span class="line">  maximum time:     <span class="number">999.731</span> μs (<span class="number">80.77</span>% GC)</span><br><span class="line">  --------------</span><br><span class="line">  samples:          <span class="number">10000</span></span><br><span class="line">  evals/sample:     <span class="number">1</span></span><br></pre></td></tr></table></figure>
<hr>
<p>Using <code>StaticArray</code> is already very fast, But this is still space to optimize it, and because <code>StaticArray</code> will<br>store everything as a type in compile time, this will force us to compile things at runtime. Before we move forward,<br>let me formalize the problem a bit more:</p>
<p>Now as you might have noticed, what we have been doing is implementing a matrix-vector multiplication but in subspace,<br>and we always know the indices inside the complement space, we just need to calculate its value in the full space, and<br>because of the control gates, we may need to add an offset to the indices in full space, but it is <code>0</code> by default,<br>thus this operation can be defined as following</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> subspace_mul!(st::<span class="built_in">AbstractVector</span>&#123;T&#125;, comspace, U, subspace, offset=<span class="number">0</span>) <span class="keyword">where</span> T</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>now let’s implement this in a plain <code>for</code> loop, if you happened to forget how to calculate matrix-vector multiplication,<br>an <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Einstein_notation">einstein summation notation</a> may help:</p>
<p>$$<br>st_{i_1,i_2,\cdots, p, \cdots, i_{n-1}, i_{n}} = U_{p,q} st_{i_1,i_2,\cdots, q, \cdots, i_{n-1}, i_{n}}<br>$$</p>
<p>where $U$ is a $2\times 2$ matrix and $p, q$ are indices in our subspace. Now we can write down our subspace multiplication<br>function</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> subspace_mul!(st::<span class="built_in">AbstractVector</span>&#123;T&#125;, comspace, U, subspace, offset=<span class="number">0</span>) <span class="keyword">where</span> T</span><br><span class="line">    indices = [idx + <span class="number">1</span> <span class="keyword">for</span> idx <span class="keyword">in</span> comspace]</span><br><span class="line">    y = similar(st, (size(U, <span class="number">1</span>), ))</span><br><span class="line">    idx = similar(indices)</span><br><span class="line"></span><br><span class="line">    <span class="meta">@inbounds</span> <span class="keyword">for</span> k <span class="keyword">in</span> subspace</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>:size(U, <span class="number">1</span>)</span><br><span class="line">            idx[i] = indices[i] + k + offset</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>:size(U, <span class="number">1</span>)</span><br><span class="line">            y[i] = zero(T)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">1</span>:size(U, <span class="number">2</span>)</span><br><span class="line">                y[i] += U[i, j] * st[idx[j]]</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>:size(U, <span class="number">1</span>)</span><br><span class="line">            st[idx[i]] = y[i]</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> st</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>if you are familiar with BLAS functions, there is a small difference with <code>gemv</code> routine: because we are doing multiplication<br>in a large space, we need to allocate a small vector to store intermediate result in the subspace and then assign the intermediate<br>result to the full space vector.</p>
<p>Now let’s use this implementation in our <code>broutine!</code> function:</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> broutine!(st::<span class="built_in">AbstractVector</span>, U::<span class="built_in">AbstractMatrix</span>, locs::<span class="built_in">NTuple</span>&#123;N, <span class="built_in">Int</span>&#125;) <span class="keyword">where</span> N</span><br><span class="line">    n = log2dim1(st)</span><br><span class="line">    subspace = bsubspace(n, locs)</span><br><span class="line">    comspace = bcomspace(n, locs)</span><br><span class="line">    subspace_mul!(st, comspace, U, subspace)</span><br><span class="line">    <span class="keyword">return</span> st</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> broutine!(st::<span class="built_in">AbstractVector</span>, U::<span class="built_in">AbstractMatrix</span>, locs::<span class="built_in">NTuple</span>&#123;N, <span class="built_in">Int</span>&#125;, ctrl_locs::<span class="built_in">NTuple</span>&#123;M, <span class="built_in">Int</span>&#125;, ctrl_configs::<span class="built_in">NTuple</span>&#123;M, <span class="built_in">Int</span>&#125;) <span class="keyword">where</span> &#123;N, M&#125;</span><br><span class="line">    n = log2dim1(st)</span><br><span class="line">    subspace = bsubspace(n, sort([locs..., ctrl_locs...]))</span><br><span class="line">    comspace = bcomspace(n, locs)</span><br><span class="line">    offset = ctrl_offset(ctrl_locs, ctrl_configs)</span><br><span class="line">    subspace_mul!(st, comspace, U, subspace, offset)</span><br><span class="line">    <span class="keyword">return</span> st</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>As you can see, it is faster now, but still slower than <code>StaticArrays</code>, this is because our compiler still has no access to the shape information<br>of your matrix</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; <span class="meta">@benchmark</span> broutine!(r, $U1, $locs) setup=(r=copy($st))</span><br><span class="line">BenchmarkTools.Trial: </span><br><span class="line">  memory estimate:  <span class="number">1008</span> bytes</span><br><span class="line">  allocs estimate:  <span class="number">11</span></span><br><span class="line">  --------------</span><br><span class="line">  minimum time:     <span class="number">247.516</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  median time:      <span class="number">282.016</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  mean time:        <span class="number">281.811</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  maximum time:     <span class="number">489.902</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  --------------</span><br><span class="line">  samples:          <span class="number">10000</span></span><br><span class="line">  evals/sample:     <span class="number">1</span></span><br></pre></td></tr></table></figure>
<hr>
<p>A direct observation is that the inner loop has a very small size in the case of quantum gates</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>:size(U, <span class="number">1</span>)</span><br><span class="line">   y[i] = zero(T)</span><br><span class="line">   <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">1</span>:size(U, <span class="number">2</span>)</span><br><span class="line">       y[i] += U[i, j] * st[idx[j]]</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>if <code>U</code> is a 2x2 matrix, this can be written as</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T1 = U[<span class="number">1</span>, <span class="number">1</span>] * st[idx[<span class="number">1</span>]] + U[<span class="number">1</span>, <span class="number">2</span>] * st[idx[<span class="number">2</span>]]</span><br><span class="line">T2 = U[<span class="number">2</span>, <span class="number">1</span>] * st[idx[<span class="number">1</span>]] + U[<span class="number">2</span>, <span class="number">2</span>] * st[idx[<span class="number">2</span>]]</span><br></pre></td></tr></table></figure>
<p>first you will find we don’t need our intermediate array <code>y</code> anymore! And moreover, notice that the order of <code>T1</code> and <code>T2</code> doesn’t matter<br>for this calculation, which means in principal they can be executed in parallel! But this is an inner loop, we don’t want to waste our<br>multi-thread resources to parallel it, instead we hope we can have <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/SIMD">SIMD</a>. And in fact the compiler<br>can figure out how to use SIMD for the 2x2 case itself, since it’s very obvious, and also because we have implicitly implied that we only<br>have a matrix of shape 2x2 by expanding the loop. So let’s just trust our compiler</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> subspace_mul2x2!(st::<span class="built_in">AbstractVector</span>&#123;T&#125;, comspace, U, subspace, offset=<span class="number">0</span>) <span class="keyword">where</span> T</span><br><span class="line">    indices_1 = comspace[<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">    indices_2 = comspace[<span class="number">2</span>] + <span class="number">1</span></span><br><span class="line">    <span class="meta">@inbounds</span> <span class="keyword">for</span> k <span class="keyword">in</span> subspace</span><br><span class="line">        idx_1 = indices_1 + k + offset</span><br><span class="line">        idx_2 = indices_2 + k + offset</span><br><span class="line"></span><br><span class="line">        T1 = U[<span class="number">1</span>, <span class="number">1</span>] * st[idx_1] + U[<span class="number">1</span>, <span class="number">2</span>] * st[idx_2]</span><br><span class="line">        T2 = U[<span class="number">2</span>, <span class="number">1</span>] * st[idx_1] + U[<span class="number">2</span>, <span class="number">2</span>] * st[idx_2]</span><br><span class="line"></span><br><span class="line">        st[idx_1] = T1</span><br><span class="line">        st[idx_2] = T2</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> st</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>we can do similar things for <code>4x4</code> and <code>8x8</code> matrices, implementing them is quite mechanical, thus we will seek some macro magic<br>now</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> subspace_mul4x4!(st::<span class="built_in">AbstractVector</span>&#123;T&#125;, comspace, U, subspace, offset=<span class="number">0</span>) <span class="keyword">where</span> T</span><br><span class="line">    Base.Cartesian.<span class="meta">@nextract</span> <span class="number">4</span> indices i -&gt; comspace[i] + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    Base.Cartesian.<span class="meta">@nextract</span> <span class="number">4</span> U i-&gt;<span class="keyword">begin</span></span><br><span class="line">        Base.Cartesian.<span class="meta">@nextract</span> <span class="number">4</span> U_i j-&gt;U[i, j]</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> subspace</span><br><span class="line">        Base.Cartesian.<span class="meta">@nextract</span> <span class="number">4</span> idx i-&gt; k + indices_i + offset</span><br><span class="line"></span><br><span class="line">        Base.Cartesian.<span class="meta">@nexprs</span> <span class="number">4</span> i -&gt; <span class="keyword">begin</span></span><br><span class="line">            y_i = zero(T)</span><br><span class="line">            Base.Cartesian.<span class="meta">@nexprs</span> <span class="number">4</span> j -&gt; <span class="keyword">begin</span></span><br><span class="line">                y_i += U_i_j * st[idx_j]</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        Base.Cartesian.<span class="meta">@nexprs</span> <span class="number">4</span> i -&gt; <span class="keyword">begin</span></span><br><span class="line">            st[idx_i] = y_i</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> st</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> subspace_mul8x8!(st::<span class="built_in">AbstractVector</span>&#123;T&#125;, comspace, U, subspace, offset=<span class="number">0</span>) <span class="keyword">where</span> T</span><br><span class="line">    Base.Cartesian.<span class="meta">@nextract</span> <span class="number">8</span> indices i -&gt; comspace[i] + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    Base.Cartesian.<span class="meta">@nextract</span> <span class="number">8</span> U i-&gt;<span class="keyword">begin</span></span><br><span class="line">        Base.Cartesian.<span class="meta">@nextract</span> <span class="number">8</span> U_i j-&gt;U[i, j]</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@inbounds</span> <span class="keyword">for</span> k <span class="keyword">in</span> subspace</span><br><span class="line">        Base.Cartesian.<span class="meta">@nextract</span> <span class="number">8</span> idx i-&gt; k + indices_i + offset</span><br><span class="line"></span><br><span class="line">        Base.Cartesian.<span class="meta">@nexprs</span> <span class="number">8</span> i -&gt; <span class="keyword">begin</span></span><br><span class="line">            y_i = zero(T)</span><br><span class="line">            Base.Cartesian.<span class="meta">@nexprs</span> <span class="number">8</span> j -&gt; <span class="keyword">begin</span></span><br><span class="line">                y_i += U_i_j * st[idx_j]</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        Base.Cartesian.<span class="meta">@nexprs</span> <span class="number">8</span> i -&gt; <span class="keyword">begin</span></span><br><span class="line">            st[idx_i] = y_i</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> st</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>In Julia the macro <code>Base.Cartesian.@nextract</code> will generate a bunch of variables like <code>indices_1</code>, <code>indice_2</code> etc.<br>automatically at compile time for us, so we don’t need to do it ourselves. And then we can use <code>Base.Cartesian.@nexprs</code><br>to implement the matrix multiplication statements and assign the values back to full space vector <code>st</code>. If you have questions<br>about how to use <code>Base.Cartesian.@nextract</code> and <code>Base.Cartesian.@nexprs</code> you can use the help mode in Julia REPL to check their<br>documentation. Now we will want to dispatch the method <code>subspace_mul!</code> to these specialized methods when we have a <code>2x2</code>, <code>4x4</code><br>or <code>8x8</code> matrix, so we move our original plain-loop version <code>subspace_mul!</code> to a new function <code>subspace_mul_generic!</code>,<br>and dispatch methods based on the matrix size</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> subspace_mul!(st::<span class="built_in">AbstractVector</span>&#123;T&#125;, comspace, U, subspace, offset=<span class="number">0</span>) <span class="keyword">where</span> T</span><br><span class="line">    <span class="keyword">if</span> size(U, <span class="number">1</span>) == <span class="number">2</span></span><br><span class="line">        subspace_mul2x2!(st, comspace, U, subspace, offset)</span><br><span class="line">    <span class="keyword">elseif</span> size(U, <span class="number">1</span>) == <span class="number">4</span></span><br><span class="line">        subspace_mul4x4!(st, comspace, U, subspace, offset)</span><br><span class="line">    <span class="keyword">elseif</span> size(U, <span class="number">1</span>) == <span class="number">8</span></span><br><span class="line">        subspace_mul8x8!(st, comspace, U, subspace, offset)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        subspace_mul_generic!(st, comspace, U, subspace, offset)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> st</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>if we try it on our previous benchmark, we will see we are faster than <code>StaticArrays</code> now!</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; <span class="meta">@benchmark</span> broutine!(r, $U1, $locs) setup=(r=copy($st))</span><br><span class="line">BenchmarkTools.Trial: </span><br><span class="line">  memory estimate:  <span class="number">512</span> bytes</span><br><span class="line">  allocs estimate:  <span class="number">8</span></span><br><span class="line">  --------------</span><br><span class="line">  minimum time:     <span class="number">141.577</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  median time:      <span class="number">145.168</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  mean time:        <span class="number">145.998</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  maximum time:     <span class="number">169.246</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  --------------</span><br><span class="line">  samples:          <span class="number">10000</span></span><br><span class="line">  evals/sample:     <span class="number">1</span></span><br></pre></td></tr></table></figure>
<hr>
<p>now since most of the quantum gates are <code>2x2</code> matrices, we will focus more on this case, recall that in the <code>2x2</code> matrix case,<br>there is only one location to specify, this will allow us to directly iterate through the subspace by adding up <code>2^loc</code>, where<br>the variable <code>loc</code> is the integer represents the location of this gate. This will get us rid of all the heavier <code>BitSubspace</code> struct.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> broutine2x2!(st::<span class="built_in">AbstractVector</span>&#123;T&#125;, U::<span class="built_in">AbstractMatrix</span>, locs::<span class="built_in">Tuple</span>&#123;<span class="built_in">Int</span>&#125;) <span class="keyword">where</span> T</span><br><span class="line">    U11 = U[<span class="number">1</span>, <span class="number">1</span>]; U12 = U[<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">    U21 = U[<span class="number">2</span>, <span class="number">1</span>]; U22 = U[<span class="number">2</span>, <span class="number">2</span>];</span><br><span class="line">    step_1 = <span class="number">1</span> &lt;&lt; (first(locs) - <span class="number">1</span>)</span><br><span class="line">    step_2 = <span class="number">1</span> &lt;&lt; first(locs)</span><br><span class="line"></span><br><span class="line">    <span class="meta">@inbounds</span> <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>:step_2:size(st, <span class="number">1</span>)-step_1</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> j+<span class="number">1</span>:j+step_1</span><br><span class="line">            ST1 = U11 * st[i] + U12 * st[i + step_1]</span><br><span class="line">            ST2 = U21 * st[i] + U22 * st[i + step_1]</span><br><span class="line"></span><br><span class="line">            st[i] = ST1</span><br><span class="line">            st[i + step_1] = ST2</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> st</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>let’s compare this and <code>subspace_mul2x2!</code>, to be fair we will directly call <code>broutine!</code> and it will call <code>subspace_mul!</code> then dispatch to <code>subspace_mul2x2!</code>.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; U = rand(<span class="built_in">ComplexF64</span>, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">julia&gt; locs = (<span class="number">3</span>, );</span><br><span class="line"></span><br><span class="line">julia&gt; st = rand(<span class="built_in">ComplexF64</span>, <span class="number">1</span>&lt;&lt;<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">julia&gt; <span class="meta">@benchmark</span> broutine!(r, $U, $locs) setup=(r=copy($st))</span><br><span class="line">BenchmarkTools.Trial: </span><br><span class="line">  memory estimate:  <span class="number">512</span> bytes</span><br><span class="line">  allocs estimate:  <span class="number">8</span></span><br><span class="line">  --------------</span><br><span class="line">  minimum time:     <span class="number">67.639</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  median time:      <span class="number">81.669</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  mean time:        <span class="number">86.487</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  maximum time:     <span class="number">125.038</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  --------------</span><br><span class="line">  samples:          <span class="number">10000</span></span><br><span class="line">  evals/sample:     <span class="number">1</span></span><br><span class="line"></span><br><span class="line">julia&gt; <span class="meta">@benchmark</span> broutine2x2!(r, $U, $locs) setup=(r=copy($st))</span><br><span class="line">BenchmarkTools.Trial: </span><br><span class="line">  memory estimate:  <span class="number">0</span> bytes</span><br><span class="line">  allocs estimate:  <span class="number">0</span></span><br><span class="line">  --------------</span><br><span class="line">  minimum time:     <span class="number">63.419</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  median time:      <span class="number">64.369</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  mean time:        <span class="number">64.757</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  maximum time:     <span class="number">86.489</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  --------------</span><br><span class="line">  samples:          <span class="number">10000</span></span><br><span class="line">  evals/sample:     <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>this is only a little bit faster. Hmm, this is not very ideal, but notice that because <code>step_1</code> can<br>be very small and it is an inner loop, we can then unroll this loop as long as it is small, so we can<br>now manually write</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> broutine2x2!(st::<span class="built_in">AbstractVector</span>&#123;T&#125;, U::<span class="built_in">AbstractMatrix</span>, locs::<span class="built_in">Tuple</span>&#123;<span class="built_in">Int</span>&#125;) <span class="keyword">where</span> T</span><br><span class="line">    U11 = U[<span class="number">1</span>, <span class="number">1</span>]; U12 = U[<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">    U21 = U[<span class="number">2</span>, <span class="number">1</span>]; U22 = U[<span class="number">2</span>, <span class="number">2</span>];</span><br><span class="line">    step_1 = <span class="number">1</span> &lt;&lt; (first(locs) - <span class="number">1</span>)</span><br><span class="line">    step_2 = <span class="number">1</span> &lt;&lt; first(locs)</span><br><span class="line"></span><br><span class="line">    <span class="meta">@inbounds</span> <span class="keyword">if</span> step_1 == <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>:step_2:size(st, <span class="number">1</span>)-step_1</span><br><span class="line">            ST1 = U11 * st[j + <span class="number">1</span>] + U12 * st[j + <span class="number">1</span> + step_1]</span><br><span class="line">            ST2 = U21 * st[j + <span class="number">1</span>] + U22 * st[j + <span class="number">1</span> + step_1]</span><br><span class="line"></span><br><span class="line">            st[j + <span class="number">1</span>] = ST1</span><br><span class="line">            st[j + <span class="number">1</span> + step_1] = ST2</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">elseif</span> step_1 == <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>:step_2:size(st, <span class="number">1</span>)-step_1</span><br><span class="line">            Base.Cartesian.<span class="meta">@nexprs</span> <span class="number">2</span> i-&gt;<span class="keyword">begin</span></span><br><span class="line">                ST1 = U11 * st[j + i] + U12 * st[j + i + step_1]</span><br><span class="line">                ST2 = U21 * st[j + i] + U22 * st[j + i + step_1]</span><br><span class="line">                st[j + i] = ST1</span><br><span class="line">                st[j + i + step_1] = ST2    </span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">elseif</span> step_1 == <span class="number">4</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>:step_2:size(st, <span class="number">1</span>)-step_1</span><br><span class="line">            Base.Cartesian.<span class="meta">@nexprs</span> <span class="number">4</span> i-&gt;<span class="keyword">begin</span></span><br><span class="line">                ST1 = U11 * st[j + i] + U12 * st[j + i + step_1]</span><br><span class="line">                ST2 = U21 * st[j + i] + U22 * st[j + i + step_1]</span><br><span class="line">                st[j + i] = ST1</span><br><span class="line">                st[j + i + step_1] = ST2    </span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">elseif</span> step_1 == <span class="number">8</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>:step_2:size(st, <span class="number">1</span>)-step_1</span><br><span class="line">            Base.Cartesian.<span class="meta">@nexprs</span> <span class="number">8</span> i-&gt;<span class="keyword">begin</span></span><br><span class="line">                ST1 = U11 * st[j + i] + U12 * st[j + i + step_1]</span><br><span class="line">                ST2 = U21 * st[j + i] + U22 * st[j + i + step_1]</span><br><span class="line">                st[j + i] = ST1</span><br><span class="line">                st[j + i + step_1] = ST2    </span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>:step_2:size(st, <span class="number">1</span>)-step_1</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> j:<span class="number">8</span>:j+step_1-<span class="number">1</span></span><br><span class="line">                Base.Cartesian.<span class="meta">@nexprs</span> <span class="number">8</span> k-&gt;<span class="keyword">begin</span></span><br><span class="line">                    ST1 = U11 * st[i + k] + U12 * st[i + step_1 + k]</span><br><span class="line">                    ST2 = U21 * st[i + k] + U22 * st[i + step_1 + k]</span><br><span class="line">                    st[i + k] = ST1</span><br><span class="line">                    st[i + step_1 + k] = ST2</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> st</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>the last loop is also partially unrolled by slicing our iteration range.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; <span class="meta">@benchmark</span> broutine2x2!(r, $U, $locs) setup=(r=copy($st))</span><br><span class="line">BenchmarkTools.Trial: </span><br><span class="line">  memory estimate:  <span class="number">0</span> bytes</span><br><span class="line">  allocs estimate:  <span class="number">0</span></span><br><span class="line">  --------------</span><br><span class="line">  minimum time:     <span class="number">21.420</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  median time:      <span class="number">21.670</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  mean time:        <span class="number">21.818</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  maximum time:     <span class="number">45.829</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  --------------</span><br><span class="line">  samples:          <span class="number">10000</span></span><br><span class="line">  evals/sample:     <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>this is now much faster than <code>subspace_mul2x2!</code>, as you see, by slightly change the abstraction<br>we implement, we exposed a small loop that can be unrolled! So let’s delete our <code>subspace_mul2x2!</code><br>and use this method instead:</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> broutine!(st::<span class="built_in">AbstractVector</span>, U::<span class="built_in">AbstractMatrix</span>, locs::<span class="built_in">NTuple</span>&#123;N, <span class="built_in">Int</span>&#125;) <span class="keyword">where</span> N</span><br><span class="line">    size(U, <span class="number">1</span>) == <span class="number">2</span> &amp;&amp; <span class="keyword">return</span> broutine!(st, U, locs)</span><br><span class="line">    n = log2dim1(st)</span><br><span class="line">    subspace = bsubspace(n, locs)</span><br><span class="line">    comspace = bcomspace(n, locs)</span><br><span class="line">    subspace_mul!(st, comspace, U, subspace)</span><br><span class="line">    <span class="keyword">return</span> st</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<hr>
<p>now let’s think about how to unroll the small matrix for the controlled gate case: the term controlled gate simply means<br>when we see there is <code>1</code> (or <code>0</code> for inverse control) at the control location, we apply the matrix in subspace, or we don’t.<br>so we can just check the control location’s configuration inside the loop, to do this we can create two masks: a control<br>location mask <code>ctrl_mask</code> and a control flag mask <code>flag_mask</code></p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctrl_mask = bmask(ctrl_locs)</span><br><span class="line">flag_mask = reduce(+, <span class="number">1</span> &lt;&lt; (ctrl_locs[i] - <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>:length(ctrl_locs) <span class="keyword">if</span> ctrl_configs[i])</span><br></pre></td></tr></table></figure>
<p>then we just need to check the bits on <code>ctrl_locs</code> to see if they are the same with <code>flag_mask</code>, we can implement a function<br><code>ismatch</code> to do this</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ismatch(index::T, mask::T, target::T) <span class="keyword">where</span> &#123;T&lt;:<span class="built_in">Integer</span>&#125; = (index &amp; mask) == target</span><br></pre></td></tr></table></figure>
<p>thus the implementation will look very similar to the un-controlled one, although it is evil to<br>copy-past, to be able to implement it within a day, I’ll just do so</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> broutine2x2!(st::<span class="built_in">AbstractVector</span>, U::<span class="built_in">AbstractMatrix</span>, locs::<span class="built_in">Tuple</span>&#123;<span class="built_in">Int</span>&#125;, ctrl_locs::<span class="built_in">NTuple</span>&#123;M, <span class="built_in">Int</span>&#125;, ctrl_configs::<span class="built_in">NTuple</span>&#123;M, <span class="built_in">Int</span>&#125;) <span class="keyword">where</span> &#123;N, M&#125;</span><br><span class="line">    step_1 = <span class="number">1</span> &lt;&lt; (first(locs) - <span class="number">1</span>)</span><br><span class="line">    step_2 = <span class="number">1</span> &lt;&lt; first(locs)</span><br><span class="line">    ctrl_mask = bmask(ctrl_locs)</span><br><span class="line">    flag_mask = reduce(+, <span class="number">1</span> &lt;&lt; (ctrl_locs[i] - <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>:length(ctrl_locs) <span class="keyword">if</span> ctrl_configs[i] == <span class="number">1</span>)</span><br><span class="line">    U11 = U[<span class="number">1</span>, <span class="number">1</span>]; U12 = U[<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">    U21 = U[<span class="number">2</span>, <span class="number">1</span>]; U22 = U[<span class="number">2</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="meta">@inbounds</span> <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>:step_2:size(st, <span class="number">1</span>)-step_1</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> j:j+step_1-<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> ismatch(i, ctrl_mask, flag_mask)</span><br><span class="line">                ST1 = U11 * st[i+<span class="number">1</span>] + U12 * st[i + step_1 + <span class="number">1</span>]</span><br><span class="line">                ST2 = U21 * st[i+<span class="number">1</span>] + U22 * st[i + step_1 + <span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">                st[i + <span class="number">1</span>] = ST1</span><br><span class="line">                st[i + step_1 + <span class="number">1</span>] = ST2</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> st</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>let’s now compare the performance</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; U = rand(<span class="built_in">ComplexF64</span>, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">julia&gt; locs = (<span class="number">3</span>, );</span><br><span class="line"></span><br><span class="line">julia&gt; ctrl = (<span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">julia&gt; flag = (<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">julia&gt; st = rand(<span class="built_in">ComplexF64</span>, <span class="number">1</span>&lt;&lt;<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">julia&gt; <span class="meta">@benchmark</span> broutine!(r, $U, $locs, $ctrl, $flag) setup=(r=copy($st))</span><br><span class="line">BenchmarkTools.Trial: </span><br><span class="line">  memory estimate:  <span class="number">736</span> bytes</span><br><span class="line">  allocs estimate:  <span class="number">10</span></span><br><span class="line">  --------------</span><br><span class="line">  minimum time:     <span class="number">17.380</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  median time:      <span class="number">23.989</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  mean time:        <span class="number">23.719</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  maximum time:     <span class="number">46.799</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  --------------</span><br><span class="line">  samples:          <span class="number">10000</span></span><br><span class="line">  evals/sample:     <span class="number">1</span></span><br><span class="line"></span><br><span class="line">julia&gt; <span class="meta">@benchmark</span> broutine2x2!(r, $U, $locs, $ctrl, $flag) setup=(r=copy($st))</span><br><span class="line">BenchmarkTools.Trial: </span><br><span class="line">  memory estimate:  <span class="number">80</span> bytes</span><br><span class="line">  allocs estimate:  <span class="number">3</span></span><br><span class="line">  --------------</span><br><span class="line">  minimum time:     <span class="number">8.283</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  median time:      <span class="number">8.423</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  mean time:        <span class="number">8.479</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  maximum time:     <span class="number">15.943</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  --------------</span><br><span class="line">  samples:          <span class="number">10000</span></span><br><span class="line">  evals/sample:     <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>Now the controlled single qubit gate routine is also improved a lot! Let’s dispatch to this too!</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> broutine!(st::<span class="built_in">AbstractVector</span>, U::<span class="built_in">AbstractMatrix</span>, locs::<span class="built_in">NTuple</span>&#123;N, <span class="built_in">Int</span>&#125;, ctrl_locs::<span class="built_in">NTuple</span>&#123;M, <span class="built_in">Int</span>&#125;, ctrl_configs::<span class="built_in">NTuple</span>&#123;M, <span class="built_in">Int</span>&#125;) <span class="keyword">where</span> &#123;N, M&#125;</span><br><span class="line">    size(U, <span class="number">1</span>) == <span class="number">2</span> &amp;&amp; <span class="keyword">return</span> broutine2x2!(st, U, locs, ctrl_locs, ctrl_configs)</span><br><span class="line">    n = log2dim1(st)</span><br><span class="line">    subspace = bsubspace(n, sort([locs..., ctrl_locs...]))</span><br><span class="line">    comspace = bcomspace(n, locs)</span><br><span class="line">    offset = ctrl_offset(ctrl_locs, ctrl_configs)</span><br><span class="line">    subspace_mul!(st, comspace, U, subspace, offset)</span><br><span class="line">    <span class="keyword">return</span> st</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Implementing-X-Gate"><a href="#Implementing-X-Gate" class="headerlink" title="Implementing X Gate"></a>Implementing X Gate</h2><p>We have implemented the most general case, but for some special gates, there are still space of improvement when we know the actual gate.<br>So what does a quantum X gate do in our emulator exactly? Let’s look at the definition of the Pauli X matrix</p>
<p>$$<br>X = \begin{pmatrix}<br>0 &amp; 1\\<br>1 &amp; 0<br>\end{pmatrix}<br>$$</p>
<p>when we apply such matrix to a vector, it actually just permutes the corresponding element. Thus we can implement this as a permutation operation directly: X gate applied to <code>k</code>-th qubit will permute all possible binary configuration <code>...0...</code> with <code>...1...</code>, where <code>0</code> and <code>1</code> is the value of <code>k</code>-th bit. If we look at our previous implementation on <code>routine2x2!</code> this becomes very obvious, we can further squeeze the performance by removing the multiplications</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> broutine!(st::<span class="built_in">AbstractVector</span>&#123;T&#125;, ::<span class="built_in">Val</span>&#123;:X&#125;, locs::<span class="built_in">Tuple</span>&#123;<span class="built_in">Int</span>&#125;) <span class="keyword">where</span> T</span><br><span class="line">    step_1 = <span class="number">1</span> &lt;&lt; (first(locs) - <span class="number">1</span>)</span><br><span class="line">    step_2 = <span class="number">1</span> &lt;&lt; first(locs)</span><br><span class="line"></span><br><span class="line">    <span class="meta">@inbounds</span> <span class="keyword">if</span> step_1 == <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>:step_2:size(st, <span class="number">1</span>)-step_1</span><br><span class="line">            tmp = st[j + <span class="number">1</span>]</span><br><span class="line">            st[j + <span class="number">1</span>] = st[j + <span class="number">1</span> + step_1]</span><br><span class="line">            st[j + <span class="number">1</span> + step_1] = tmp</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">elseif</span> step_1 == <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>:step_2:size(st, <span class="number">1</span>)-step_1</span><br><span class="line">            Base.Cartesian.<span class="meta">@nexprs</span> <span class="number">2</span> i-&gt;<span class="keyword">begin</span></span><br><span class="line">                tmp = st[j + i]</span><br><span class="line">                st[j + i] = st[j + i + step_1]</span><br><span class="line">                st[j + i + step_1] = tmp</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">elseif</span> step_1 == <span class="number">4</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>:step_2:size(st, <span class="number">1</span>)-step_1</span><br><span class="line">            Base.Cartesian.<span class="meta">@nexprs</span> <span class="number">4</span> i-&gt;<span class="keyword">begin</span></span><br><span class="line">                tmp = st[j + i]</span><br><span class="line">                st[j + i] = st[j + i + step_1]</span><br><span class="line">                st[j + i + step_1] = tmp</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">elseif</span> step_1 == <span class="number">8</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>:step_2:size(st, <span class="number">1</span>)-step_1</span><br><span class="line">            Base.Cartesian.<span class="meta">@nexprs</span> <span class="number">8</span> i-&gt;<span class="keyword">begin</span></span><br><span class="line">                tmp = st[j + i]</span><br><span class="line">                st[j + i] = st[j + i + step_1]</span><br><span class="line">                st[j + i + step_1] = tmp</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>:step_2:size(st, <span class="number">1</span>)-step_1</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> j:<span class="number">8</span>:j+step_1-<span class="number">1</span></span><br><span class="line">                Base.Cartesian.<span class="meta">@nexprs</span> <span class="number">8</span> k-&gt;<span class="keyword">begin</span></span><br><span class="line">                    tmp = st[i+k]</span><br><span class="line">                    st[i+k] = st[i + step_1 + k]</span><br><span class="line">                    st[i + step_1 + k] = tmp</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> st</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>However, this does not gain much performance anymore</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; U = [<span class="number">0</span> <span class="number">1</span>;<span class="number">1</span> <span class="number">0</span>]</span><br><span class="line"><span class="number">2</span>×<span class="number">2</span> <span class="built_in">Array</span>&#123;<span class="built_in">Int64</span>,<span class="number">2</span>&#125;:</span><br><span class="line"> <span class="number">0</span>  <span class="number">1</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">0</span></span><br><span class="line"></span><br><span class="line">julia&gt; <span class="meta">@benchmark</span> broutine!(r, $U, $locs) setup=(r=copy($st))</span><br><span class="line">BenchmarkTools.Trial: </span><br><span class="line">  memory estimate:  <span class="number">0</span> bytes</span><br><span class="line">  allocs estimate:  <span class="number">0</span></span><br><span class="line">  --------------</span><br><span class="line">  minimum time:     <span class="number">5.708</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  median time:      <span class="number">5.962</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  mean time:        <span class="number">6.007</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  maximum time:     <span class="number">11.841</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  --------------</span><br><span class="line">  samples:          <span class="number">10000</span></span><br><span class="line">  evals/sample:     <span class="number">6</span></span><br><span class="line"></span><br><span class="line">julia&gt; <span class="meta">@benchmark</span> broutine!(r, <span class="built_in">Val</span>(:X), $locs) setup=(r=copy($st))</span><br><span class="line">BenchmarkTools.Trial: </span><br><span class="line">  memory estimate:  <span class="number">0</span> bytes</span><br><span class="line">  allocs estimate:  <span class="number">0</span></span><br><span class="line">  --------------</span><br><span class="line">  minimum time:     <span class="number">4.001</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  median time:      <span class="number">4.614</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  mean time:        <span class="number">4.583</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  maximum time:     <span class="number">7.975</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  --------------</span><br><span class="line">  samples:          <span class="number">10000</span></span><br><span class="line">  evals/sample:     <span class="number">8</span></span><br></pre></td></tr></table></figure>
<h2 id="Parallelize-using-Multi-threads"><a href="#Parallelize-using-Multi-threads" class="headerlink" title="Parallelize using Multi-threads"></a>Parallelize using Multi-threads</h2><p>Now since we have implemented general matrix instructions, we should be able to simulate arbitrary quantum circuit. We can now parallel what we have implemented using multi-thread directly as we mentioned at the beginning. However, multi-threading is not always beneficial, it has a small overhead. Thus we may not want it when the number of qubits is not large enough.</p>
<p>We will implement a <code>@_threads</code> macro as following</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">macro</span> _threads(ex)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">quote</span></span><br><span class="line">        <span class="keyword">if</span> (Threads.nthreads() &gt; <span class="number">1</span>) &amp;&amp; (length(st) &gt; <span class="number">4096</span>)</span><br><span class="line">            $(<span class="built_in">Expr</span>(:macrocall, <span class="built_in">Expr</span>(:(.), :Threads, <span class="built_in">QuoteNode</span>(<span class="built_in">Symbol</span>(<span class="string">&quot;@threads&quot;</span>))), __source__, ex))</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            $ex</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span> |&gt; esc</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="Parallelize-using-CUDA"><a href="#Parallelize-using-CUDA" class="headerlink" title="Parallelize using CUDA"></a>Parallelize using CUDA</h2><p>Now, we have implemented Pauli gates and a general matrix instructions. Let’s parallelize them using <a target="_blank" rel="noopener" href="https://github.com/JuliaGPU/CUDA.jl">CUDA.jl</a>. Since we are not using general purpose matrix multiplication anymore, we need to write our<br>own CUDA kernels, but this is actually not very hard in Julia, because we can reuse a lot code from our previous implementation.</p>
<p>But before we start doing this, let me explain what is a kernel function in the context of CUDA programming. As you might have known, GPU devices<br>are special chip designed for executing a lot similar tasks in parallel. These tasks can be described via a function. Executing the kernel function<br>on GPU is in equivalent to execute this function on CPU within a huge loop.</p>
<p>So as you have realized, this kernel function is exactly the same thing we unrolled in previous implementation. Thus we can quickly turn out previous CPU<br>implementation into GPU implementation by wrapping the kernel into a closure, which is very mechanical. Although, the best way to do this is to move the<br>overlapping part into a function, to demonstrate things more clearly in the blog post I just simply copy paste the previous implementation.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> broutine!(st::CuVector&#123;T&#125;, U::<span class="built_in">AbstractMatrix</span>, locs::<span class="built_in">Tuple</span>&#123;<span class="built_in">Int</span>&#125;) <span class="keyword">where</span> T</span><br><span class="line">    U11 = U[<span class="number">1</span>, <span class="number">1</span>]; U12 = U[<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">    U21 = U[<span class="number">2</span>, <span class="number">1</span>]; U22 = U[<span class="number">2</span>, <span class="number">2</span>];</span><br><span class="line">    step_1 = <span class="number">1</span> &lt;&lt; (first(locs) - <span class="number">1</span>)</span><br><span class="line">    step_2 = <span class="number">1</span> &lt;&lt; first(locs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> kernel(st)</span><br><span class="line">        idx = (blockIdx().x - <span class="number">1</span>) * blockDim().x + threadIdx().x</span><br><span class="line">        j = step_2 * idx - step_2</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> j+<span class="number">1</span>:j+step_1</span><br><span class="line">            ST1 = U11 * st[i] + U12 * st[i + step_1]</span><br><span class="line">            ST2 = U21 * st[i] + U22 * st[i + step_1]</span><br><span class="line"></span><br><span class="line">            st[i] = ST1</span><br><span class="line">            st[i + step_1] = ST2</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    N = length(<span class="number">0</span>:step_2:size(st, <span class="number">1</span>)-step_1)</span><br><span class="line">    nblocks = ceil(<span class="built_in">Int</span>, N/<span class="number">256</span>)</span><br><span class="line">    <span class="meta">@cuda</span> threads=<span class="number">256</span> blocks=nblocks kernel(st)</span><br><span class="line">    <span class="keyword">return</span> st</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> broutine!(st::CuVector&#123;T&#125;, U::<span class="built_in">AbstractMatrix</span>, locs::<span class="built_in">Tuple</span>&#123;<span class="built_in">Int</span>&#125;, ctrl_locs::<span class="built_in">NTuple</span>&#123;M, <span class="built_in">Int</span>&#125;, ctrl_configs::<span class="built_in">NTuple</span>&#123;M, <span class="built_in">Int</span>&#125;) <span class="keyword">where</span> &#123;T, M&#125;</span><br><span class="line">    step_1 = <span class="number">1</span> &lt;&lt; (first(locs) - <span class="number">1</span>)</span><br><span class="line">    step_2 = <span class="number">1</span> &lt;&lt; first(locs)</span><br><span class="line">    ctrl_mask = bmask(ctrl_locs)</span><br><span class="line">    flag_mask = reduce(+, <span class="number">1</span> &lt;&lt; (ctrl_locs[i] - <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>:length(ctrl_locs) <span class="keyword">if</span> ctrl_configs[i] == <span class="number">1</span>)</span><br><span class="line">    U11 = U[<span class="number">1</span>, <span class="number">1</span>]; U12 = U[<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">    U21 = U[<span class="number">2</span>, <span class="number">1</span>]; U22 = U[<span class="number">2</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> kernel(st)</span><br><span class="line">        idx = (blockIdx().x - <span class="number">1</span>) * blockDim().x + threadIdx().x</span><br><span class="line">        j = step_2 * idx - step_2</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> j:j+step_1-<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> ismatch(i, ctrl_mask, flag_mask)</span><br><span class="line">                ST1 = U11 * st[i+<span class="number">1</span>] + U12 * st[i + step_1 + <span class="number">1</span>]</span><br><span class="line">                ST2 = U21 * st[i+<span class="number">1</span>] + U22 * st[i + step_1 + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">                st[i + <span class="number">1</span>] = ST1</span><br><span class="line">                st[i + step_1 + <span class="number">1</span>] = ST2</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    N = length(<span class="number">0</span>:step_2:size(st, <span class="number">1</span>)-step_1)</span><br><span class="line">    nblocks = ceil(<span class="built_in">Int</span>, N/<span class="number">256</span>)</span><br><span class="line">    <span class="meta">@cuda</span> threads=<span class="number">256</span> blocks=nblocks kernel(st)</span><br><span class="line">    <span class="keyword">return</span> st</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="Benchmark"><a href="#Benchmark" class="headerlink" title="Benchmark"></a>Benchmark</h2><p>Now let’s see how fast is our ~600 line of code quantum circuit emulator. I don’t mean to go through a complete benchmark<br>since the above implementation is generic it will has similar benchmark on different kinds of gates. And there are still plenty<br>of room to optimize. The benchmark of multi-threaded routines and CUDA is currently missing since I don’t have access to a<br>GPU with <code>ComplexF64</code> support to make the comparision fair. However, this blog post is a simple implementation of<br><a target="_blank" rel="noopener" href="https://github.com/QuantumBFS/YaoArrayRegister.jl">YaoArrayRegister</a><br>in the <a target="_blank" rel="noopener" href="https://yaoquantum.org/">Yao</a> ecosystem, you can use the benchmark of Yao for reference. Or please also feel free to<br>benchmark the implementation and play with it in this blog post yourself for sure!</p>
<p>Let me compare this with one of the current best performance simulator <a target="_blank" rel="noopener" href="https://github.com/qulacs/qulacs">qulacs</a>, you should be able<br>to find relative benchmark comparing qulacs and other software <a target="_blank" rel="noopener" href="https://github.com/Roger-luo/quantum-benchmarks/blob/release-0.1/RESULTS.md">here</a>.<br>(I’m not comparing with Yao because the implementation is similar to what is implemented in Yao.)</p>
<p>first we clone the benchmark repo</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/Roger-luo/quantum-benchmarks.git</span><br></pre></td></tr></table></figure>
<p>then checkout to the stable release branch <code>release-0.1</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> quantum-benchmarks &amp;&amp; git checkout release-0.1</span><br><span class="line">bin/benchmark setup qulacs</span><br><span class="line">bin/benchmark run qulacs</span><br></pre></td></tr></table></figure>
<p>this will prepare us the benchmark data on our machine. then we benchmark our own implementation</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> BenchmarkTools</span><br><span class="line"></span><br><span class="line">data = <span class="built_in">Dict</span>(</span><br><span class="line">    <span class="string">&quot;X&quot;</span> =&gt; [],</span><br><span class="line">    <span class="string">&quot;T&quot;</span> =&gt; [],</span><br><span class="line">    <span class="string">&quot;H&quot;</span> =&gt; [],</span><br><span class="line">    <span class="string">&quot;CNOT&quot;</span> =&gt; [],</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="number">4</span>:<span class="number">25</span></span><br><span class="line">    st = rand(<span class="built_in">ComplexF64</span>, <span class="number">1</span>&lt;&lt;n)</span><br><span class="line">    t = <span class="meta">@benchmark</span> broutine!(r, $([<span class="number">0</span> <span class="number">1</span>;<span class="number">1</span> <span class="number">0</span>]), (<span class="number">3</span>, )) setup=(r=copy($st))</span><br><span class="line">    push!(data[<span class="string">&quot;X&quot;</span>], minimum(t).time)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="number">4</span>:<span class="number">25</span></span><br><span class="line">    st = rand(<span class="built_in">ComplexF64</span>, <span class="number">1</span>&lt;&lt;n)</span><br><span class="line">    t = <span class="meta">@benchmark</span> broutine!(r, $([<span class="number">1</span> <span class="number">0</span>;<span class="number">0</span> exp(<span class="literal">im</span> * <span class="literal">π</span> / <span class="number">4</span>)]), (<span class="number">3</span>, )) setup=(r=copy($st))</span><br><span class="line">    push!(data[<span class="string">&quot;T&quot;</span>], minimum(t).time)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="number">4</span>:<span class="number">25</span></span><br><span class="line">    st = rand(<span class="built_in">ComplexF64</span>, <span class="number">1</span>&lt;&lt;n)</span><br><span class="line">    t = <span class="meta">@benchmark</span> broutine!(r, $([<span class="number">1</span>/sqrt(<span class="number">2</span>) <span class="number">1</span>/sqrt(<span class="number">2</span>); <span class="number">1</span>/sqrt(<span class="number">2</span>) -<span class="number">1</span>/sqrt(<span class="number">2</span>)]), (<span class="number">3</span>, )) setup=(r=copy($st))</span><br><span class="line">    push!(data[<span class="string">&quot;H&quot;</span>], minimum(t).time)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="number">4</span>:<span class="number">25</span></span><br><span class="line">    st = rand(<span class="built_in">ComplexF64</span>, <span class="number">1</span>&lt;&lt;n)</span><br><span class="line">    t = <span class="meta">@benchmark</span> broutine!(r, $([<span class="number">0</span> <span class="number">1</span>;<span class="number">1</span> <span class="number">0</span>]), (<span class="number">2</span>, ), (<span class="number">3</span>, ), (<span class="number">1</span>, )) setup=(r=copy($st))</span><br><span class="line">    push!(data[<span class="string">&quot;X&quot;</span>], minimum(t).time)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><em>note: we always use minimum time as a stable estimator for benchmarks</em></p>
<p>now we plot the benchmark of <code>X</code>, <code>H</code>, <code>T</code>, <code>CNOT</code>.</p>
<p><img src="/images/implement-your-own-qc-simulator/benchmark.png" alt="benchmark"></p>
<h2 id="What’s-more"><a href="#What’s-more" class="headerlink" title="What’s more?"></a>What’s more?</h2><p>Recall our previous implementation, since we didn’t specify our matrix type or vector type<br>to be a <code>Vector</code> or other concrete type, and didn’t specify the element type has to be a <code>ComplexF64</code> either,<br>this means ANY subtype of <code>AbstractVector</code>, and ANY subtype of <code>Number</code> can be used with the above methods.<br>Now we can do something interesting, e.g we can automatically get the ability of symbolic calculation by<br>feeding symbolic number type from <code>SymEngine</code> package or <code>SymbolicUtils</code> package.<br>Or we can use <code>Dual</code> number to perform forward mode differentiation directly. Or we can estimate error<br>by using the error numbers from <code>Measurements</code>.</p>
<p>Here is demo of using <code>SymEngine</code>:</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> SymEngine</span><br><span class="line"></span><br><span class="line">julia&gt; <span class="meta">@vars</span> α θ</span><br><span class="line">(α, θ)</span><br><span class="line"></span><br><span class="line">julia&gt; st = Basic[<span class="number">1</span>, α, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"><span class="number">4</span>-element <span class="built_in">Array</span>&#123;Basic,<span class="number">1</span>&#125;:</span><br><span class="line"> <span class="number">1</span></span><br><span class="line"> α</span><br><span class="line"> <span class="number">0</span></span><br><span class="line"> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">julia&gt; broutine!(st, [exp(-<span class="literal">im</span> * θ) <span class="number">0</span>; <span class="number">0</span> exp(<span class="literal">im</span> * θ)], (<span class="number">1</span>, ))</span><br><span class="line"><span class="number">4</span>-element <span class="built_in">Array</span>&#123;Basic,<span class="number">1</span>&#125;:</span><br><span class="line">  exp(-<span class="literal">im</span>*θ)</span><br><span class="line"> exp(<span class="literal">im</span>*θ)*α</span><br><span class="line">           <span class="number">0</span></span><br><span class="line">           <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>This the magic of generic programming.</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Getting similar performance or beyond comparing to Python/C++ solution in numerical computation<br>is easily achievable in pure Julia with much less code. Moreover, the power of generic programming<br>will unleash our thinking of numerical methods.</p>
<p>Experienced readers may find there may still rooms for further optimization, e.g we didn’t specialize<br>much common gates yet, and the loop unroll size might not be the perfect size, and may still vary due<br>to the machine.</p>
<p>Last, besides simulating quantum circuits, the above implementation of subspace matrix multiplication<br>is actually a quite common routine happens frequently in tensor contraction (well quantum circuits are<br>one kind of tensor network), thus more promising application can be using these routines for tensor<br>contraction, however, that may require us to implement BLAS level 3 operation which is the subspace<br>matrix-matrix multiplication, which can require more tricks.</p>
<hr>
<p>I uploaded the implementation as a gist: <a target="_blank" rel="noopener" href="https://gist.github.com/Roger-luo/0df73cabf4c91f9854657fdd2ed66767">https://gist.github.com/Roger-luo/0df73cabf4c91f9854657fdd2ed66767</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rogerluo.me/blog/2019/07/27/yassad/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xiu-Zhe (Roger) Luo">
      <meta itemprop="description" content="Where I writes about Machine Learning, Quanutm Physics, and more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Half Integer">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/27/yassad/" class="post-title-link" itemprop="url">Implement Your Own Source To Source AD in ONE day!</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-07-27 14:49:33" itemprop="dateCreated datePublished" datetime="2019-07-27T14:49:33-04:00">2019-07-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-21 03:06:56" itemprop="dateModified" datetime="2020-12-21T03:06:56-05:00">2020-12-21</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2019/07/27/yassad/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/07/27/yassad/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>I wrote a blog post about how to implement your own (operator overloading based) automatic differentiation (AD) in one day (actually 3 hrs) last year. AD looks like magic sometimes, but I’m going to talk about some black magic this time: the source<br>to source automatic differentiation. I wrote this during JuliaCon 2019 hackthon with help from <a target="_blank" rel="noopener" href="https://github.com/MikeInnes">Mike Innes</a>.<br>It turns out that writing a blog post takes longer than writing a source to source AD ;-). This is basically just simple version of Zygote.</p>
<p>I wrap this thing as a very simple package here, if you want to look at more detailed implementation: <a target="_blank" rel="noopener" href="https://github.com/Roger-luo/YASSAD.jl">YASSAD.jl</a>.</p>
<p>If you have used operator overloading based AD like <a target="_blank" rel="noopener" href="https://github.com/pytorch/pytorch">PyTorch</a>, <a target="_blank" rel="noopener" href="https://github.com/FluxML/Tracker.jl">Flux/Tracker</a>, <a target="_blank" rel="noopener" href="https://github.com/HIPS/autograd">AutoGrad</a>, you may find they have some limitations:</p>
<ul>
<li>A <code>Tensor</code> type or <code>Variable</code> type provided by the package has to be used for tracing the function calls</li>
<li>They cannot handle control flows in general, even in some cases, some workarounds can be taken</li>
</ul>
<p>However, programming without control flow is not programming! And it is usually very annoying to rewrite a lot code with tracked types. If we want to have a framework for <strong>Differentiable Programming</strong> as what people like <strong>Yan LeCun</strong> has been proposing, we need to solve these two problems above.</p>
<p>In fact, these problems are quite straight forward to solve in source to source automatic differentiation, since we basically know everything happens. I will implement a very simple source to source AD without handling control flows, you can also check the complete implementation as <a target="_blank" rel="noopener" href="https://github.com/FluxML/Zygote.jl">Zygote.jl</a>.</p>
<p>But before we start, let’s review some basic knowledge.</p>
<h2 id="Basics"><a href="#Basics" class="headerlink" title="Basics"></a>Basics</h2><h3 id="The-compilation-process-of-Julia-language"><a href="#The-compilation-process-of-Julia-language" class="headerlink" title="The compilation process of Julia language"></a>The compilation process of Julia language</h3><p>I will briefly introduce how Julia program is compiled and run in this section:</p>
<ol>
<li>all the code are just strings</li>
<li>the Julia parser will parse the strings first to get an Abstract Syntax Tree (AST)</li>
<li>some of the nodes in this AST are macros, macros are like compiled time functions on expressions, the compiler will expand the macros. Then we get an expanded version of AST, which do not have any macros. You can inspect the results with <code>@macroexpand</code>.</li>
<li>Now, we will lower the AST, get rid of syntax sugars and represent them in Static Single Assignment Form (SSA), you can get it with <code>@code_lowered</code>, and you can modify this process with Julia <code>macro</code>s.</li>
<li>When function call happens, we use the function signature to dispatch the function to a certain method, and start doing type inference. You can modify this process with <code>@generated</code> functions, and check the results with <code>@code_typed</code>.</li>
<li>The compiler will then generate the llvm IR. You can inspect them with <code>@code_llvm</code></li>
<li>After we have llvm IR, Julia will use llvm to generate native code to actually exectute this function.</li>
<li>By executing the function, we will meet another function call, so we go back to step 5</li>
</ol>
<p>I steal a diagram from JuliaCon 2018 to demonstrate this process:</p>
<p><img src="/images/julia-compile-diagram.png"></p>
<p>As you can see. Julia is not a static compiled language, and it uses function as boundary of compilation.</p>
<h3 id="SSA-Form-IR"><a href="#SSA-Form-IR" class="headerlink" title="SSA Form IR"></a>SSA Form IR</h3><p>A complete introduction of SSA can be <a target="_blank" rel="noopener" href="http://ssabook.gforge.inria.fr/latest/book.pdf">a book</a>. But to implement your own source<br>to source AD only require three simple concept:</p>
<ul>
<li>all the variable will only be assigned once</li>
<li>most variable comes from function calls</li>
<li>all the control flows become branches</li>
</ul>
<p>If you have read my last post, I believe you have understand what is computation graph, but now let’s look at this diagram again: what is this computation graph exactly?</p>
<p><img src="/images/comput-graph-forward.gif" alt="comput-graph"></p>
<p>While doing the automatic differentiation, we represent the process of computation as a diagram. Each node is an operator with a intermediate value. And each operator also have an <strong>adjoint operator</strong> which will be used in backward pass. Which means each variable<br>in each node will only be assigned once. This is just a simple version of SSA Form right?</p>
<p>The gradient can be then considered as an adjoint program of the original program. And the only thing we need to do is to generate the adjoint program. In fact, this is often called Wengert list, tape or graph as described in <a target="_blank" rel="noopener" href="https://arxiv.org/pdf/1810.07951.pdf">Zygote’s paper: Don’t Unroll Adjoint</a>. Thus we can directly use the SSA form as our computational graph. Moreover, since in Julia the SSA form IR is lowered, it also means we only need to defined a few primitive routines instead of defining a lot operators.</p>
<p>Since the backward pass is just an adjoint of the original program, we can just write it as a closure</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> forward(::typeof(your_function), xs...)</span><br><span class="line">    <span class="comment"># function declaration</span></span><br><span class="line">    output = <span class="comment"># function output</span></span><br><span class="line">    output, <span class="keyword">function</span> (Δ)</span><br><span class="line">        <span class="comment"># a closure</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>The advantage of defining this as closure is that we can let the compiler itself handle shared variable between the adjoint program<br>and the original program instead of managing it ourselves (like what we do in my last post). We call these closures <strong>pullback</strong>s.</p>
<p>So given a function like the following</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> foo(x)</span><br><span class="line">    a = bar(x)</span><br><span class="line">    b = baz(x)</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>If we do this manually, we only need to define a <code>forward</code> function</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> forward(::typeof(foo), x)</span><br><span class="line">      x1, back1 = forward(baz, x)</span><br><span class="line">      x2, back2 = forward(bar, x1)</span><br><span class="line">      <span class="keyword">return</span> x2, <span class="keyword">function</span> (Δ)</span><br><span class="line">         dx1 = back2(Δ)</span><br><span class="line">         dx2 = back1(dx1)</span><br><span class="line">         <span class="keyword">return</span> dx2</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>In general, an adjoint program without control flow is just applying these pullbacks generated by their <strong>forward</strong> function in reversed order. But how do we do this automatically? Someone may say: let’s use macros! Err, we can do that. But our goal is to differentiate arbitrary function defined by someone else, so things can be composable. This is not what we want. Instead, we can tweak the IR, the <strong>generated function</strong>s in Julia can not only return a modified AST from type information, it can also return the IR.</p>
<p>The generated function can be declared with a <code>@generated</code> macro</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@generated</span> <span class="keyword">function</span> foo(a, b, c)</span><br><span class="line">    <span class="keyword">return</span> :(<span class="number">1</span> + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>It looks like a function as well, but the difference is that inside the function, the value of each function argument <code>a</code>, <code>b</code>, <code>c</code><br>is their type since we do not have their values during compile time.</p>
<p><img src="/images/julia-generated-compile-diagram.png"></p>
<p>In order to manipulate the IR, we need some tools. Fortunately, there are some in <a target="_blank" rel="noopener" href="https://github.com/MikeInnes/IRTools.jl">IRTools</a>, we will use this package to generate the IR code.</p>
<p>First, we can use <code>@code_ir</code> to get the <code>IR</code> object processed by <code>IRTools</code>. Its type is <code>IR</code>. The difference between the one you get from <code>@code_lowered</code> is that this will not store the argument name, all the variables are represented by numbers, and there are some useful function implemented for this type.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; <span class="meta">@code_ir</span> foo(<span class="number">1.0</span>)</span><br><span class="line"><span class="number">1</span>: (%<span class="number">1</span>, %<span class="number">2</span>)</span><br><span class="line">  %<span class="number">3</span> = (Main.baz)(%<span class="number">2</span>)</span><br><span class="line">  %<span class="number">4</span> = (Main.bar)(%<span class="number">3</span>)</span><br><span class="line">  <span class="keyword">return</span> %<span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>In this form, each line of code is binded to a variable, we call the right hand statement, and left hand variable. You use a dict-like interface to use this object, e.g</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; <span class="keyword">using</span> IRTools: var</span><br><span class="line"></span><br><span class="line">julia&gt; ir[var(<span class="number">3</span>)]</span><br><span class="line">IRTools.Statement(:((Main.baz)(%<span class="number">2</span>)), <span class="built_in">Any</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>It will return a statement object, which stores the expression of this statement, the inferred type (since we are using the IR before type inference, this is <code>Any</code>). For simplicity, we will not use typed IR in this post (since in principal, their implementations are similar). The last number is the line number.</p>
<p>What is the first number <code>1</code> in the whole block? It means code block, in SSA form we use this to represent branches, e.g</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; <span class="keyword">function</span> foo(x)</span><br><span class="line">           <span class="keyword">if</span> x &gt; <span class="number">1</span></span><br><span class="line">               bar(x)</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               baz(x)</span><br><span class="line">           <span class="keyword">end</span></span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">foo (generic <span class="keyword">function</span> with <span class="number">1</span> method)</span><br><span class="line"></span><br><span class="line">julia&gt; <span class="meta">@code_ir</span> foo(<span class="number">1.0</span>)</span><br><span class="line"><span class="number">1</span>: (%<span class="number">1</span>, %<span class="number">2</span>)</span><br><span class="line">  %<span class="number">3</span> = %<span class="number">2</span> &gt; <span class="number">1</span></span><br><span class="line">  br <span class="number">3</span> unless %<span class="number">3</span></span><br><span class="line"><span class="number">2</span>:</span><br><span class="line">  %<span class="number">4</span> = (Main.bar)(%<span class="number">2</span>)</span><br><span class="line">  <span class="keyword">return</span> %<span class="number">4</span></span><br><span class="line"><span class="number">3</span>:</span><br><span class="line">  %<span class="number">5</span> = (Main.baz)(%<span class="number">2</span>)</span><br><span class="line">  <span class="keyword">return</span> %<span class="number">5</span></span><br></pre></td></tr></table></figure>
<p><code>ifelse</code> is just branch statement in lowered SSA form, and in fact, <code>for</code> loops are similar. Julia’s for loop is just a syntax sugar of <code>iterate</code> function. As long as we can differentiate through <code>br</code>, we will be able to differentiate through control flows.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; <span class="keyword">function</span> foo(x)</span><br><span class="line">           <span class="keyword">for</span> x <span class="keyword">in</span> <span class="number">1</span>:<span class="number">10</span></span><br><span class="line">               bar(x)</span><br><span class="line">           <span class="keyword">end</span></span><br><span class="line">           baz(x)</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">foo (generic <span class="keyword">function</span> with <span class="number">1</span> method)</span><br><span class="line"></span><br><span class="line">julia&gt; <span class="meta">@code_ir</span> foo(<span class="number">1.0</span>)</span><br><span class="line"><span class="number">1</span>: (%<span class="number">1</span>, %<span class="number">2</span>)</span><br><span class="line">  %<span class="number">3</span> = <span class="number">1</span>:<span class="number">10</span></span><br><span class="line">  %<span class="number">4</span> = (Base.iterate)(%<span class="number">3</span>)</span><br><span class="line">  %<span class="number">5</span> = %<span class="number">4</span> === <span class="literal">nothing</span></span><br><span class="line">  %<span class="number">6</span> = (Base.not_int)(%<span class="number">5</span>)</span><br><span class="line">  br <span class="number">3</span> unless %<span class="number">6</span></span><br><span class="line">  br <span class="number">2</span> (%<span class="number">4</span>)</span><br><span class="line"><span class="number">2</span>: (%<span class="number">7</span>)</span><br><span class="line">  %<span class="number">8</span> = (Core.getfield)(%<span class="number">7</span>, <span class="number">1</span>)</span><br><span class="line">  %<span class="number">9</span> = (Core.getfield)(%<span class="number">7</span>, <span class="number">2</span>)</span><br><span class="line">  %<span class="number">10</span> = (Main.bar)(%<span class="number">8</span>)</span><br><span class="line">  %<span class="number">11</span> = (Base.iterate)(%<span class="number">3</span>, %<span class="number">9</span>)</span><br><span class="line">  %<span class="number">12</span> = %<span class="number">11</span> === <span class="literal">nothing</span></span><br><span class="line">  %<span class="number">13</span> = (Base.not_int)(%<span class="number">12</span>)</span><br><span class="line">  br <span class="number">3</span> unless %<span class="number">13</span></span><br><span class="line">  br <span class="number">2</span> (%<span class="number">11</span>)</span><br><span class="line"><span class="number">3</span>:</span><br><span class="line">  %<span class="number">14</span> = (Main.baz)(%<span class="number">2</span>)</span><br><span class="line">  <span class="keyword">return</span> %<span class="number">14</span></span><br></pre></td></tr></table></figure>
<p>So how do we get the IR? In order to get the IR, we need to know which method is dispatched for this generic function. Each generic<br>function in Julia has a method table, you can use the type signature of the function call to get this method, e.g when you call <code>foo(1.0)</code>, Julia will generate <code>Tuple&#123;typeof(foo), Float64&#125;</code> to call the related method. We can get the meta information of this method by providing the <code>IRTools.meta</code> function with this type signature</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; IRTools.IR(m)</span><br><span class="line"><span class="number">1</span>: (%<span class="number">1</span>, %<span class="number">2</span>)</span><br><span class="line">  %<span class="number">3</span> = (Main.baz)(%<span class="number">2</span>)</span><br><span class="line">  %<span class="number">4</span> = (Main.bar)(%<span class="number">3</span>)</span><br><span class="line">  <span class="keyword">return</span> %<span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>And we can manipulate this IR with functions like <code>push!</code>:</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; push!(ir, :(<span class="number">1</span>+<span class="number">1</span>))</span><br><span class="line">%<span class="number">5</span></span><br><span class="line"></span><br><span class="line">julia&gt; ir</span><br><span class="line"><span class="number">1</span>: (%<span class="number">1</span>, %<span class="number">2</span>)</span><br><span class="line">  %<span class="number">3</span> = (Main.baz)(%<span class="number">2</span>)</span><br><span class="line">  %<span class="number">4</span> = (Main.bar)(%<span class="number">3</span>)</span><br><span class="line">  %<span class="number">5</span> = <span class="number">1</span> + <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> %<span class="number">4</span></span><br></pre></td></tr></table></figure>
<p><code>IRTools</code> will add the variable name for you automatically here. Similarly, we can use <code>insert!</code> to insert a statement before the 4th variable:</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; <span class="keyword">using</span> IRTools: var</span><br><span class="line"></span><br><span class="line">julia&gt; insert!(ir, var(<span class="number">4</span>), :(<span class="number">1</span>+<span class="number">1</span>))</span><br><span class="line">%<span class="number">5</span></span><br><span class="line"></span><br><span class="line">julia&gt; ir</span><br><span class="line"><span class="number">1</span>: (%<span class="number">1</span>, %<span class="number">2</span>)</span><br><span class="line">  %<span class="number">3</span> = (Main.baz)(%<span class="number">2</span>)</span><br><span class="line">  %<span class="number">5</span> = <span class="number">1</span> + <span class="number">1</span></span><br><span class="line">  %<span class="number">4</span> = (Main.bar)(%<span class="number">3</span>)</span><br><span class="line">  <span class="keyword">return</span> %<span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>Or we can insert a statement after the 4th variable:</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; <span class="keyword">using</span> IRTools: insertafter!</span><br><span class="line"></span><br><span class="line">julia&gt; insertafter!(ir, var(<span class="number">4</span>), :(<span class="number">2</span>+<span class="number">2</span>))</span><br><span class="line">%<span class="number">6</span></span><br><span class="line"></span><br><span class="line">julia&gt; ir</span><br><span class="line"><span class="number">1</span>: (%<span class="number">1</span>, %<span class="number">2</span>)</span><br><span class="line">  %<span class="number">3</span> = (Main.baz)(%<span class="number">2</span>)</span><br><span class="line">  %<span class="number">5</span> = <span class="number">1</span> + <span class="number">1</span></span><br><span class="line">  %<span class="number">4</span> = (Main.bar)(%<span class="number">3</span>)</span><br><span class="line">  %<span class="number">6</span> = <span class="number">2</span> + <span class="number">2</span></span><br><span class="line">  <span class="keyword">return</span> %<span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>With these tools, we can now do the transformation of forward pass. Our goal is to replace each function call with the function call to <code>forward</code> function and then collect all the pullbacks returned by <code>forward</code> function to generate a closure. But wait! I didn’t mention closure, what is the closure in SSA IR? Let’s consider this later, and implement the transformation of forward part first.</p>
<p>Let’s take a statement and have a look</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; dump(ir[var(<span class="number">3</span>)])</span><br><span class="line">IRTools.Statement</span><br><span class="line">  expr: <span class="built_in">Expr</span></span><br><span class="line">    head: <span class="built_in">Symbol</span> call</span><br><span class="line">    args: <span class="built_in">Array</span>&#123;<span class="built_in">Any</span>&#125;((<span class="number">2</span>,))</span><br><span class="line">      <span class="number">1</span>: <span class="built_in">GlobalRef</span></span><br><span class="line">        mod: <span class="built_in">Module</span> Main</span><br><span class="line">        name: <span class="built_in">Symbol</span> baz</span><br><span class="line">      <span class="number">2</span>: IRTools.Variable</span><br><span class="line">        id: <span class="built_in">Int64</span> <span class="number">2</span></span><br><span class="line">  type: <span class="built_in">Any</span></span><br><span class="line">  line: <span class="built_in">Int64</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>In fact, we only need to check whether the signature of its expression is <code>call</code>. We can use the <code>Pipe</code> object in <code>IRTools</code> to do the transformation, the transformation results are stored in its member <code>to</code>.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; IRTools.<span class="built_in">Pipe</span>(ir).to</span><br><span class="line"><span class="number">1</span>: (%<span class="number">1</span>, %<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><h3 id="Forward-Transformation"><a href="#Forward-Transformation" class="headerlink" title="Forward Transformation"></a>Forward Transformation</h3><p>We name this function as <code>register</code> since it has similar functionality as our old <code>register</code> function in my last post. The only difference is: you don’t need to write this <code>register</code> function manually for each operator now! We are going to do this automatically. </p>
<p><strong>Warning</strong>: since I’m doing this demo in REPL, I use <code>Main</code> module directly, if you put the code in your own module, replace it with your module name.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> register(ir)</span><br><span class="line">    pr = <span class="built_in">Pipe</span>(ir)</span><br><span class="line">    argument!(pr, at = <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> (v, st) <span class="keyword">in</span> pr</span><br><span class="line">        ex = st.expr</span><br><span class="line">        <span class="keyword">if</span> Meta.isexpr(ex, :call)</span><br><span class="line">            yJ = insert!(pr, v, stmt(xcall(Main, :forward, ex.args...), line = ir[v].line))</span><br><span class="line">            pr[v] = xgetindex(yJ, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    finish(pr)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>I’ll explain what I do here: first since we are generating the IR for the <code>forward</code> function, we have an extra argument now</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">forward(f, args...)</span><br></pre></td></tr></table></figure>
<p>Thus, I added one argument at the beginning of this function’s IR.</p>
<p>Then, we need to iterate through all the variables and statements, if the statement is a function call then we replace it with the call<br>to <code>forward</code> function. Remember to keep the line number here, since we still want some error message. Since the returned value of <code>forward</code> is a tuple of actually forward evaluation and the pullback, to get the correct result we need to index this tuple, and replace<br>the original variable with the new one. The <code>xgetindex</code> here is a convenient function that generates the expression of <code>getindex</code></p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xgetindex(x, i...) = xcall(Base, :getindex, x, i...)</span><br></pre></td></tr></table></figure>
<p>Let’s see what we get</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; register(ir)</span><br><span class="line"><span class="number">1</span>: (%<span class="number">3</span>, %<span class="number">1</span>, %<span class="number">2</span>)</span><br><span class="line">  %<span class="number">4</span> = (Main.forward)(Main.baz, %<span class="number">2</span>)</span><br><span class="line">  %<span class="number">5</span> = (Base.getindex)(%<span class="number">4</span>, <span class="number">1</span>)</span><br><span class="line">  %<span class="number">6</span> = (Main.forward)(Main.bar, %<span class="number">5</span>)</span><br><span class="line">  %<span class="number">7</span> = (Base.getindex)(%<span class="number">6</span>, <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> %<span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>Nice! We change the function call to forward now!</p>
<p>Now, it’s time to consider the closure problem. Yes, in this lowered form, we don’t have closures. But we can instead store them in a callable object!</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Pullback&#123;S, T&#125;</span><br><span class="line">    data::T</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">Pullback&#123;S&#125;(data::T) <span class="keyword">where</span> &#123;S, T&#125; = Pullback&#123;S, T&#125;(data)</span><br></pre></td></tr></table></figure>
<p>This object will also store the function signature, so when we call pullback, we can look up the IR of the original call to generate the IR of this pullback. The member <code>data</code> here will store a <code>Tuple</code> of all pullbacks with the order of their <code>forward</code> call. In order to construct the <code>Pullback</code> we need the signature of our function call, so we need to revise our implementation as following.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> register(ir, F)</span><br><span class="line">    pr = <span class="built_in">Pipe</span>(ir)</span><br><span class="line">    pbs = Variable[]</span><br><span class="line">    argument!(pr, at = <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> (v, st) <span class="keyword">in</span> pr</span><br><span class="line">        ex = st.expr</span><br><span class="line">        <span class="keyword">if</span> Meta.isexpr(ex, :call)</span><br><span class="line">            yJ = insert!(pr, v, stmt(xcall(Main, :forward, ex.args...), line = ir[v].line))</span><br><span class="line">            pr[v] = xgetindex(yJ, <span class="number">1</span>)</span><br><span class="line">            J = insertafter!(pr, v, stmt(xgetindex(yJ, <span class="number">2</span>), line = ir[v].line))</span><br><span class="line">            push!(pbs, substitute(pr, J))</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    pr = finish(pr)</span><br><span class="line">    v = push!(pr, xtuple(pbs...))</span><br><span class="line">    pbv = push!(pr, <span class="built_in">Expr</span>(:call, Pullback&#123;F&#125;, v))</span><br><span class="line">    <span class="keyword">return</span> pr</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>In order to store the pullbacks, we need to get the pullback from the tuple returned by <code>forward</code> and allocate a list to record all pullbacks.</p>
<p>Here <code>xtuple</code> is similar to <code>xgetindex</code>, it is used to generate the expression of constructing a tuple.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xtuple(xs...) = xcall(Core, :tuple, xs...)</span><br></pre></td></tr></table></figure>
<p>Let’s pack the pullback and the original returned value as a tuple together, and return it!</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> register(ir, F)</span><br><span class="line">    pr = <span class="built_in">Pipe</span>(ir)</span><br><span class="line">    pbs = Variable[]</span><br><span class="line">    argument!(pr, at = <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> (v, st) <span class="keyword">in</span> pr</span><br><span class="line">        ex = st.expr</span><br><span class="line">        <span class="keyword">if</span> Meta.isexpr(ex, :call)</span><br><span class="line">            yJ = insert!(pr, v, stmt(xcall(Main, :forward, ex.args...), line = ir[v].line))</span><br><span class="line">            pr[v] = xgetindex(yJ, <span class="number">1</span>)</span><br><span class="line">            J = insertafter!(pr, v, stmt(xgetindex(yJ, <span class="number">2</span>), line = ir[v].line))</span><br><span class="line">            push!(pbs, substitute(pr, J))</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    pr = finish(pr)</span><br><span class="line">    v = push!(pr, xtuple(pbs...))</span><br><span class="line">    pbv = push!(pr, <span class="built_in">Expr</span>(:call, Pullback&#123;F&#125;, v))</span><br><span class="line">    ret = pr.blocks[<span class="keyword">end</span>].branches[<span class="keyword">end</span>].args[<span class="number">1</span>]</span><br><span class="line">    ret = push!(pr, xtuple(ret, pbv))</span><br><span class="line">    pr.blocks[<span class="keyword">end</span>].branches[<span class="keyword">end</span>].args[<span class="number">1</span>] = ret</span><br><span class="line">    <span class="keyword">return</span> pr, pbs</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>The <code>return</code> statement is actually a simple branch, it is the last branch of the last statement of the last code block.</p>
<p>OK, let’s see what we get now</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; register(ir, <span class="built_in">Tuple</span>&#123;typeof(foo), <span class="built_in">Float64</span>&#125;)</span><br><span class="line"><span class="number">1</span>: (%<span class="number">3</span>, %<span class="number">1</span>, %<span class="number">2</span>)</span><br><span class="line">  %<span class="number">4</span> = (Main.forward)(Main.baz, %<span class="number">2</span>)</span><br><span class="line">  %<span class="number">5</span> = (Base.getindex)(%<span class="number">4</span>, <span class="number">1</span>)</span><br><span class="line">  %<span class="number">6</span> = (Base.getindex)(%<span class="number">4</span>, <span class="number">2</span>)</span><br><span class="line">  %<span class="number">7</span> = (Main.forward)(Main.bar, %<span class="number">5</span>)</span><br><span class="line">  %<span class="number">8</span> = (Base.getindex)(%<span class="number">7</span>, <span class="number">1</span>)</span><br><span class="line">  %<span class="number">9</span> = (Base.getindex)(%<span class="number">7</span>, <span class="number">2</span>)</span><br><span class="line">  %<span class="number">10</span> = (Core.tuple)(%<span class="number">9</span>, %<span class="number">6</span>)</span><br><span class="line">  %<span class="number">11</span> = (Pullback&#123;<span class="built_in">Tuple</span>&#123;typeof(foo),<span class="built_in">Float64</span>&#125;,T&#125; <span class="keyword">where</span> T)(%<span class="number">10</span>)</span><br><span class="line">  %<span class="number">12</span> = (Core.tuple)(%<span class="number">8</span>, %<span class="number">11</span>)</span><br><span class="line">  <span class="keyword">return</span> %<span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>Now let’s implement the <code>forward</code> function</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@generated</span> <span class="keyword">function</span> forward(f, xs...)</span><br><span class="line">    T = <span class="built_in">Tuple</span>&#123;f, xs...&#125;</span><br><span class="line">    m = IRTools.meta(T)</span><br><span class="line">    m === <span class="literal">nothing</span> &amp;&amp; <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>We will get the meta first, if the meta is <code>nothing</code>, it means this method doesn’t exist, so we just stop here. If we have the meta, then<br>we can get the <code>IR</code> from it and put it to <code>register</code></p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@generated</span> <span class="keyword">function</span> forward(f, xs...)</span><br><span class="line">    T = <span class="built_in">Tuple</span>&#123;f, xs...&#125;</span><br><span class="line">    m = IRTools.meta(T)</span><br><span class="line">    m === <span class="literal">nothing</span> &amp;&amp; <span class="keyword">return</span></span><br><span class="line">    frw = register(IR(m), T)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>However, the object <code>frw</code> has type <code>IR</code> instead of <code>CodeInfo</code>, to generate the <code>CodeInfo</code> for Julia compiler, we need to put argument names back with</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">argnames!(m, <span class="built_in">Symbol</span>(<span class="string">&quot;#self#&quot;</span>), :f, :xs)</span><br></pre></td></tr></table></figure>
<p>And since the second argument of our <code>forward</code> function is a vararg, we need to tag it to let our compiler know, so the compiler will not feed the first function call with a <code>Tuple</code>.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frw = varargs!(m, frw, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>In the end, our forward function will looks like</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@generated</span> <span class="keyword">function</span> forward(f, xs...)</span><br><span class="line">    T = <span class="built_in">Tuple</span>&#123;f, xs...&#125;</span><br><span class="line">    m = IRTools.meta(T)</span><br><span class="line">    m === <span class="literal">nothing</span> &amp;&amp; <span class="keyword">return</span></span><br><span class="line">    frw = register(IR(m), T)</span><br><span class="line">    argnames!(m, <span class="built_in">Symbol</span>(<span class="string">&quot;#self#&quot;</span>), :f, :xs)</span><br><span class="line">    frw = varargs!(m, frw, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> IRTools.update!(m, frw)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>Let’s see what we got now</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; <span class="meta">@code_ir</span> forward(foo, <span class="number">1.0</span>)</span><br><span class="line"><span class="number">1</span>: (%<span class="number">1</span>, %<span class="number">2</span>, %<span class="number">3</span>)</span><br><span class="line">  %<span class="number">4</span> = (Base.getfield)(%<span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line">  %<span class="number">5</span> = (Main.forward)(Main.baz, %<span class="number">4</span>)</span><br><span class="line">  %<span class="number">6</span> = (Base.getindex)(%<span class="number">5</span>, <span class="number">1</span>)</span><br><span class="line">  %<span class="number">7</span> = (Base.getindex)(%<span class="number">5</span>, <span class="number">2</span>)</span><br><span class="line">  %<span class="number">8</span> = (Main.forward)(Main.bar, %<span class="number">6</span>)</span><br><span class="line">  %<span class="number">9</span> = (Base.getindex)(%<span class="number">8</span>, <span class="number">1</span>)</span><br><span class="line">  %<span class="number">10</span> = (Base.getindex)(%<span class="number">8</span>, <span class="number">2</span>)</span><br><span class="line">  %<span class="number">11</span> = (Core.tuple)(%<span class="number">10</span>, %<span class="number">7</span>)</span><br><span class="line">  %<span class="number">12</span> = (Main.Pullback&#123;<span class="built_in">Tuple</span>&#123;typeof(foo),<span class="built_in">Float64</span>&#125;,T&#125; <span class="keyword">where</span> T)(%<span class="number">11</span>)</span><br><span class="line">  %<span class="number">13</span> = (Core.tuple)(%<span class="number">9</span>, %<span class="number">12</span>)</span><br><span class="line">  <span class="keyword">return</span> %<span class="number">13</span></span><br></pre></td></tr></table></figure>
<p>If you try to actually run this, there will be some error unfortunately</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; forward(foo, <span class="number">1.0</span>)</span><br><span class="line">ERROR: <span class="built_in">MethodError</span>: no method matching getindex(::<span class="built_in">Nothing</span>, ::<span class="built_in">Int64</span>)</span><br><span class="line">Stacktrace:</span><br><span class="line"> [<span class="number">1</span>] * at ./float.jl:<span class="number">399</span> [inlined]</span><br><span class="line"> [<span class="number">2</span>] forward(::typeof(*), ::<span class="built_in">Float64</span>, ::<span class="built_in">Float64</span>) at /Users/roger/.julia/dev/YASSAD/src/compiler.jl:<span class="number">0</span></span><br><span class="line"> [<span class="number">3</span>] baz at ./REPL[<span class="number">4</span>]:<span class="number">1</span> [inlined]</span><br><span class="line"> [<span class="number">4</span>] forward(::typeof(baz), ::<span class="built_in">Float64</span>) at /Users/roger/.julia/dev/YASSAD/src/compiler.jl:<span class="number">0</span></span><br><span class="line"> [<span class="number">5</span>] foo at ./REPL[<span class="number">2</span>]:<span class="number">1</span> [inlined]</span><br><span class="line"> [<span class="number">6</span>] forward(::typeof(foo), ::<span class="built_in">Float64</span>) at /Users/roger/.julia/dev/YASSAD/src/compiler.jl:<span class="number">0</span></span><br><span class="line"> [<span class="number">7</span>] top-level scope at none:<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>This is because the <code>forward</code> will be recursively called, which also means we only need to define the inner most (primitive) operators by overloading the <code>forward</code> functions, e.g we can overload the <code>*</code> operator in this case</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; forward(::typeof(*), a::<span class="built_in">Real</span>, b::<span class="built_in">Real</span>) = a * b, Δ-&gt;(Δ*b, a*Δ)</span><br><span class="line"></span><br><span class="line">julia&gt; forward(foo, <span class="number">1.0</span>)</span><br><span class="line">(<span class="number">1.0</span>, YASSAD.Pullback&#123;.....&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Backward-Transformation"><a href="#Backward-Transformation" class="headerlink" title="Backward Transformation"></a>Backward Transformation</h3><p>But this pullback is not callable yet. Let’s generate the IR for pullback. Similarly, we can define</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@generated</span> <span class="keyword">function</span> (::Pullback&#123;S&#125;)(delta) <span class="keyword">where</span> S</span><br><span class="line">    m = IRTools.meta(S)</span><br><span class="line">    m === <span class="literal">nothing</span> &amp;&amp; <span class="keyword">return</span></span><br><span class="line">    ir = IR(m)</span><br><span class="line">    _, pbs = register(ir, S)</span><br><span class="line">    back = adjoint(ir, pbs)</span><br><span class="line">    argnames!(m, <span class="built_in">Symbol</span>(<span class="string">&quot;#self#&quot;</span>), :delta)</span><br><span class="line">    <span class="keyword">return</span> IRTools.update!(m, back)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>Because the backward pass is called separately, we don’t have the forward IR anymore, unfortunately we need to call <code>register</code> again here, but no worries, this will only happen once during compile time. Before we generate the IR for adjoint program, we also need to know which variable has pullback, thus instead of using a list, we need a dict to store this, and return it to pullback. Therefore, we need to revise our <code>register</code> as following</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> register(ir, F)</span><br><span class="line">    pr = <span class="built_in">Pipe</span>(ir)</span><br><span class="line">    pbs = <span class="built_in">Dict</span>&#123;Variable, Variable&#125;()</span><br><span class="line">    argument!(pr, at = <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> (v, st) <span class="keyword">in</span> pr</span><br><span class="line">        ex = st.expr</span><br><span class="line">        <span class="keyword">if</span> Meta.isexpr(ex, :call)</span><br><span class="line">            yJ = insert!(pr, v, stmt(xcall(Main, :forward, ex.args...), line = ir[v].line))</span><br><span class="line">            pr[v] = xgetindex(yJ, <span class="number">1</span>)</span><br><span class="line">            J = insertafter!(pr, v, stmt(xgetindex(yJ, <span class="number">2</span>), line = ir[v].line))</span><br><span class="line">            pbs[v] = substitute(pr, J)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    pr = finish(pr)</span><br><span class="line">    v = push!(pr, xtuple(values(pbs)...))</span><br><span class="line">    pbv = push!(pr, <span class="built_in">Expr</span>(:call, Pullback&#123;F&#125;, v))</span><br><span class="line">    ret = pr.blocks[<span class="keyword">end</span>].branches[<span class="keyword">end</span>].args[<span class="number">1</span>]</span><br><span class="line">    ret = push!(pr, xtuple(ret, pbv))</span><br><span class="line">    pr.blocks[<span class="keyword">end</span>].branches[<span class="keyword">end</span>].args[<span class="number">1</span>] = ret</span><br><span class="line">    <span class="keyword">return</span> pr, pbs</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>since the adjoint program has the reversed order with the original IR, we will not use <code>Pipe</code> here, we can create an empty <code>IR</code> object,<br>and add two argument to it here, one is the <code>Pullback</code> object itself, the other is the input gradient of the backward pass (pullback).</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adj = empty(ir)</span><br><span class="line">self = argument!(adj)</span><br><span class="line">delta = argument!(adj)</span><br></pre></td></tr></table></figure>
<p>First, let’s get our pullbacks. The <code>getfield</code> function I call here is the lowered form of syntax sugar <code>.</code> for getting members, this is equivalent to <code>self.data</code>.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pullbacks = pushfirst!(adj, xcall(:getfield, self, <span class="built_in">QuoteNode</span>(:data)))</span><br></pre></td></tr></table></figure>
<p>Then let’s iterate the all the variables in reversed order</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vars = keys(ir)</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> length(vars):-<span class="number">1</span>:<span class="number">1</span></span><br><span class="line">    v = vars[k]</span><br><span class="line">    ex = ir[v].expr</span><br><span class="line">    <span class="keyword">if</span> haskey(pbs, v)</span><br><span class="line">        pbv = insertafter!(adj, pullbacks, xcall(:getindex, pullbacks, k))</span><br><span class="line">        g = push!(adj, <span class="built_in">Expr</span>(:call, pbv, v))</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>if this variable exists in our dict of pullbacks, we get it and call it with this variable. However, there is a problem of this implementation, if one variable has multiple gradient, we need to accumulate them together, thus we need to record these variables’<br>gradietns as well.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grads = <span class="built_in">Dict</span>()</span><br></pre></td></tr></table></figure>
<p>Then we can implement two method of <code>grad</code>:</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grad(x, x̄) = push!(get!(grads, x, []), x̄)</span><br></pre></td></tr></table></figure>
<p>Store the gradient <code>x̄</code> in the list of <code>x</code> in <code>grads</code>.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grad(x) = xaccum(adj, get(grads, x, [])...)</span><br></pre></td></tr></table></figure>
<p>Return the accumulated variable of all gradients.</p>
<p>The <code>xaccum</code> is the same as previous <code>xgetindex</code>, but the builtin <code>accumulate</code> function in Julia is defined on arrays, we need one to accumulate variant variables, let’s do it ourselves</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">xaccum(ir) = <span class="literal">nothing</span></span><br><span class="line">xaccum(ir, x) = x</span><br><span class="line">xaccum(ir, xs...) = push!(ir, xcall(YASSAD, :accum, xs...))</span><br><span class="line">accum() = <span class="literal">nothing</span></span><br><span class="line">accum(x) = x</span><br><span class="line">accum(x, y) =</span><br><span class="line">  x == <span class="literal">nothing</span> ? y :</span><br><span class="line">  y == <span class="literal">nothing</span> ? x :</span><br><span class="line">  x + y</span><br><span class="line"></span><br><span class="line">accum(x, y, zs...) = accum(accum(x, y), zs...)</span><br><span class="line"></span><br><span class="line">accum(x::<span class="built_in">Tuple</span>, y::<span class="built_in">Tuple</span>) = accum.(x, y)</span><br><span class="line">accum(x::<span class="built_in">AbstractArray</span>, y::<span class="built_in">AbstractArray</span>) = accum.(x, y)</span><br></pre></td></tr></table></figure>
<p>In the end, the pullback will return each input variable’s gradient of the original program. Which means it always has<br>the same number of gradients as input variables. But our <code>forward</code> function has one extra variable which is the function,<br>we will return its gradient as well, in most cases, it is <code>nothing</code>, but if it is a closure, or a callable object, it may<br>not be <code>nothing</code>.</p>
<p>So, in the end, our <code>adjoint</code> function looks like</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> adjoint(ir, pbs)</span><br><span class="line">    adj = empty(ir)</span><br><span class="line">    self = argument!(adj)</span><br><span class="line">    delta = argument!(adj)</span><br><span class="line">    pullbacks = pushfirst!(adj, xcall(:getfield, self, <span class="built_in">QuoteNode</span>(:data)))</span><br><span class="line"></span><br><span class="line">    grads = <span class="built_in">Dict</span>()</span><br><span class="line">    grad(x, x̄) = push!(get!(grads, x, []), x̄)</span><br><span class="line">    grad(x) = xaccum(adj, get(grads, x, [])...)</span><br><span class="line">    grad(last(keys(ir)), delta)</span><br><span class="line"></span><br><span class="line">    vars = keys(ir)</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> length(vars):-<span class="number">1</span>:<span class="number">1</span></span><br><span class="line">        v = vars[k]</span><br><span class="line">        ex = ir[v].expr</span><br><span class="line">        <span class="keyword">if</span> haskey(pbs, v)</span><br><span class="line">            pbv = insertafter!(adj, pullbacks, xcall(:getindex, pullbacks, k))</span><br><span class="line">            g = push!(adj, <span class="built_in">Expr</span>(:call, pbv, grad(v)))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (i, x) <span class="keyword">in</span> enumerate(ex.args)</span><br><span class="line">                x <span class="keyword">isa</span> Variable || <span class="keyword">continue</span></span><br><span class="line">                grad(x, push!(adj, xgetindex(g, i)))</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    gs = [grad(x) <span class="keyword">for</span> x <span class="keyword">in</span> arguments(ir)]</span><br><span class="line">    Δ = push!(adj, xtuple(gs...))</span><br><span class="line">    <span class="keyword">return</span>!(adj, Δ)</span><br><span class="line">    <span class="keyword">return</span> adj</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="Contextual-Dispatch"><a href="#Contextual-Dispatch" class="headerlink" title="Contextual Dispatch"></a>Contextual Dispatch</h2><p>Reviewing what we just implemented above, we can find we were actually just dispatching functions based on their context instead of<br>their signature (since the signature is used to dispatch the function themselves). The Julia community actually implements something<br>more general: the <a target="_blank" rel="noopener" href="https://github.com/jrevels/Cassette.jl">Cassette.jl</a>. Cassette can dispatch function based on a context, and it also contains an implementation of AD as well: <a target="_blank" rel="noopener" href="https://github.com/jrevels/Cassette.jl/blob/a67c8e98ea975203e46b913807a86de5d3e84130/test/misctaggingtests.jl#L402">Cassette/test</a>. With these mechanism, and the dynamic feature of Julia, we are not only able to implement source to source AD, we can also have</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/JuliaDiffEq/SparsityDetection.jl">Sparsity Detection</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/FluxML/Hydra.jl">SPMD transformation</a></li>
<li>Intermediate Variable Optimization</li>
<li>Debugger: <a target="_blank" rel="noopener" href="https://github.com/oxinabox/MagneticReadHead.jl">MagneticReadHead</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/JuliaGPU/CUDAnative.jl/pull/334">Unified Interface of CUDAnative</a></li>
</ul>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Let’s try this with matrix multiplication + matrix trace, which is the same with what we do in our last post!</p>
<p>Look! we can use the builtin types directly!</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> LinearAlgebra</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> forward(::typeof(*), A::<span class="built_in">Matrix</span>, B::<span class="built_in">Matrix</span>)</span><br><span class="line">    A * B, <span class="keyword">function</span> (Δ::<span class="built_in">Matrix</span>)</span><br><span class="line">        Base.<span class="meta">@_inline_meta</span></span><br><span class="line">        (<span class="literal">nothing</span>, Δ * B&#x27;, A&#x27; * Δ)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> forward(::typeof(tr), A::<span class="built_in">Matrix</span>)</span><br><span class="line">    tr(A), <span class="keyword">function</span> (Δ::<span class="built_in">Real</span>)</span><br><span class="line">        Base.<span class="meta">@_inline_meta</span></span><br><span class="line">        (<span class="literal">nothing</span>, Δ * <span class="built_in">Matrix</span>(I, size(A)))</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">julia&gt; <span class="keyword">using</span> LinearAlgebra, BenchmarkTools</span><br><span class="line"></span><br><span class="line">julia&gt; mul_tr(A::<span class="built_in">Matrix</span>, B::<span class="built_in">Matrix</span>) = tr(A * B)</span><br><span class="line">mul_tr (generic <span class="keyword">function</span> with <span class="number">1</span> method)</span><br><span class="line"></span><br><span class="line">julia&gt; A, B = rand(<span class="number">30</span>, <span class="number">30</span>), rand(<span class="number">30</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">julia&gt; mul_tr(A, B)</span><br><span class="line"><span class="number">216.7247235502547</span></span><br><span class="line"></span><br><span class="line">julia&gt; z, back = forward(mul_tr, A, B)；</span><br><span class="line"></span><br><span class="line">julia&gt; julia&gt; back(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>The performance is similar to the manual implementation as well (in fact it should be the same)</p>
<p>The manual version is:</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; <span class="meta">@benchmark</span> bench_tr_mul_base($(rand(<span class="number">30</span>, <span class="number">30</span>)), $(rand(<span class="number">30</span>, <span class="number">30</span>)))</span><br><span class="line">BenchmarkTools.Trial: </span><br><span class="line">  memory estimate:  <span class="number">28.78</span> KiB</span><br><span class="line">  allocs estimate:  <span class="number">5</span></span><br><span class="line">  --------------</span><br><span class="line">  minimum time:     <span class="number">10.696</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  median time:      <span class="number">13.204</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  mean time:        <span class="number">24.075</span> μs (<span class="number">43.31</span>% GC)</span><br><span class="line">  maximum time:     <span class="number">62.964</span> ms (<span class="number">99.97</span>% GC)</span><br><span class="line">  --------------</span><br><span class="line">  samples:          <span class="number">10000</span></span><br><span class="line">  evals/sample:     <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>the generated version:</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; <span class="meta">@benchmark</span> tr_mul($A, $B)</span><br><span class="line">BenchmarkTools.Trial: </span><br><span class="line">  memory estimate:  <span class="number">36.17</span> KiB</span><br><span class="line">  allocs estimate:  <span class="number">14</span></span><br><span class="line">  --------------</span><br><span class="line">  minimum time:     <span class="number">12.921</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  median time:      <span class="number">15.659</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  mean time:        <span class="number">27.304</span> μs (<span class="number">40.97</span>% GC)</span><br><span class="line">  maximum time:     <span class="number">60.141</span> ms (<span class="number">99.94</span>% GC)</span><br><span class="line">  --------------</span><br><span class="line">  samples:          <span class="number">10000</span></span><br><span class="line">  evals/sample:     <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>Now we have implemented a very simple source to source automatic differentiation, but we didn’t handle control flow here. A more<br>complete implementation can be find in <code>Zygote.jl/compiler</code>, it can differentiate through almost everything, including: self defined types, control flows, foreign function calls (e.g you can differentiate <code>PyTorch</code> functions!), and <code>in-place</code> function (mutation support). This also includes part of our quantum algorithm design framework <a target="_blank" rel="noopener" href="https://github.com/QuantumBFS/Yao.jl">Yao.jl</a> with some custom primitives.</p>
<p>Our implementation here only costs 132 lines of code in Julia. Even the complete implementation’s compiler only costs 495 lines of code. It is possible to finish in one or a few days!</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rogerluo.me/blog/2018/10/23/write-an-ad-in-one-day/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xiu-Zhe (Roger) Luo">
      <meta itemprop="description" content="Where I writes about Machine Learning, Quanutm Physics, and more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Half Integer">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/10/23/write-an-ad-in-one-day/" class="post-title-link" itemprop="url">Implement Your Own Automatic Differentiation with Julia in ONE day</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-10-23 00:00:00" itemprop="dateCreated datePublished" datetime="2018-10-23T00:00:00-04:00">2018-10-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-21 03:06:56" itemprop="dateModified" datetime="2020-12-21T03:06:56-05:00">2020-12-21</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2018/10/23/write-an-ad-in-one-day/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/10/23/write-an-ad-in-one-day/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>I was playing with <a target="_blank" rel="noopener" href="https://github.com/denizyuret/AutoGrad.jl">AutoGrad.jl</a> and <a target="_blank" rel="noopener" href="https://github.com/FluxML/Zygote.jl">Zygote.jl</a>, they both look<br>awesome, and AutoGrad.jl has already been applied to the machine learning framework in Julia: <a target="_blank" rel="noopener" href="https://github.com/denizyuret/Knet.jl">Knet.jl</a>. When I tried to read the source code of AutoGrad.jl, it is actually quite simple and small.</p>
<p>But, as a PyTorch contributor and user, I personally prefer some of PyTorch’s interfaces (both frontend and backend), and as a Julian, I want to see how simple it can be to write a Julia AD package. Therefore, I tried to implemented my own automatic differentiation and it just took me one day to finished the core part (including broadcast!).</p>
<p>Although, I spent a few hours more during the next following days to polish the interface (a weekend to write a blog post). But it is actually quite easy to implement an automatic differentiation package in Julia.</p>
<p>I packed it to a package (YAAD.jl: Yet Another AD package for Julia) here: <a target="_blank" rel="noopener" href="https://github.com/Roger-luo/YAAD.jl">Roger-luo/YAAD.jl</a></p>
<p>In this post, I’ll introduce how did I implemented my own automatic differentiation, and maybe, you can build one of your own as well!</p>
<h2 id="Automatic-Differentiation-A-Brief-Intro"><a href="#Automatic-Differentiation-A-Brief-Intro" class="headerlink" title="Automatic Differentiation: A Brief Intro"></a>Automatic Differentiation: A Brief Intro</h2><p>There are generally two kinds of automatic differentiation: forward mode differentiation and reverse mode differentiation. What we need in deep learning (as well as tensor networks in physics) is the reverse mode differentiation, because the model we are going to optimize usually contains quite a lot parameters. This is also called as back-propagation and requires something called comput-graph.</p>
<h3 id="Comput-Graph"><a href="#Comput-Graph" class="headerlink" title="Comput-Graph"></a>Comput-Graph</h3><p><em>To illustrate this, I stole some nice picture and re-ploted them in animation from cs5740, 2017sp, Cornell.</em></p>
<p>Say we are calculating the following expression:</p>
<p>$$<br>y = \mathbf{x}^T \mathbf{A} \mathbf{x} + \mathbf{b}\cdot \mathbf{x} + c<br>$$</p>
<p>We will need to call several functions in Julia to get the result $y$, which is</p>
<ol>
<li>$\mathbf{z_1} = \mathbf{x}^T$: <code>transpose</code> function.</li>
<li>$\mathbf{z_2} = \mathbf{z_1} A$ matrix-vector multiplication, which can be <code>gemv</code> in <code>LinearAlgebra.BLAS</code>, or just <code>*</code>.</li>
<li>$y_1 = \mathbf{z_2} \mathbf{x}$ vector dot operation, which is <code>LinearAlgebra.dot</code> or the UTF-8 operator <code>x ⋅ y</code></li>
<li>$y_2 = \mathbf{b} \cdot \mathbf{x}$ another vector dot</li>
<li>$y_1 + y_2 + c$ a scalar add function, one can calculate it by simply calling <code>+</code> operator in Julia.</li>
</ol>
<p>In fact, we can draw a graph of this expression, which illustrates the relationship between each variable in this expression.<br>Each node in the graph with an output arrow represents a variable and each node with an input arrow represents a function/operator.</p>
<p><img src="/images/comput-graph-forward.gif" alt="comput-graph"></p>
<p>The evaluation of the math equation above can then be expressed as a process called <strong>forward evaluation</strong>, it starts from the leaf nodes, which represents the inputs of the whole expression, e.g they are $\mathbf{x}, \mathbf{A}, \mathbf{b}, c$ in our expression. Each time, we receive the value of a node in the graph, we mark the node with <strong>green</strong>.</p>
<p>Now, let’s calculate the gradients with <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Chain_rule"><strong>chain rule</strong></a>, the number of gradients returned by each function is the same as their inputs. We mark the node red if we receive a gradient, the gradient will be back propagated through the graph, which is called <strong>back propagation</strong> or <strong>backward evaluation</strong>.</p>
<p><img src="/images/comput-graph-backward.gif" alt="comput-graph"></p>
<h3 id="Dynamic-Comput-Graphs-VS-Static-Comput-Graphs"><a href="#Dynamic-Comput-Graphs-VS-Static-Comput-Graphs" class="headerlink" title="Dynamic Comput Graphs VS Static Comput Graphs"></a>Dynamic Comput Graphs VS Static Comput Graphs</h3><p>Although, the way of forward evaluation and backward evaluation are actually the same, but for implementation, we can construct the graph on the fly (like in <a target="_blank" rel="noopener" href="https://github.com/pytorch/pytorch">PyTorch</a>) or as a static declaration (like in  <a target="_blank" rel="noopener" href="https://github.com/tensorflow/tensorflow">TensorFlow</a>).</p>
<p>Generally, the difference between them is that:</p>
<p><strong>Whether the graph is defined before the forward evaluation happens or along with the forward evaluation.</strong></p>
<p>I’m a PyTorch syntax lover, so I’m going to implement my AD as a dynamic constructed graph. But I’m also planning to write a macro in Julia that “freeze” a dynamic graph to static graph, because in principle, static graph is easier to optimize, since we will be able to access the whole graph before evaluation happens, which allows us to dispatch methods statically, but static graphs can be hard to debug.</p>
<h2 id="Define-the-Nodes-in-the-Computational-Graph"><a href="#Define-the-Nodes-in-the-Computational-Graph" class="headerlink" title="Define the Nodes in the Computational Graph"></a>Define the Nodes in the Computational Graph</h2><p>Well, before we start writing something concrete, we can first define an <code>abstract type</code> for all nodes we are going to define:</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract type</span> AbstractNode <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="Leaf-Nodes"><a href="#Leaf-Nodes" class="headerlink" title="Leaf Nodes"></a>Leaf Nodes</h3><p>Same, define an <code>abstract type</code> first.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract type</span> LeafNode &lt;: AbstractNode <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>In PyTorch, a <code>Variable</code> is a multi-dimensional array (tensor) with a gradient (also store in a multi-dimensional array of the same size and data type). And it will accumulate the gradient if we back-propagate the graph for multiple times.</p>
<p>Accumulating is sometimes useful, when you want to calculate the expectation of the gradient, or manipulate a batch of data, but not always useful. But anyway, we have an abstract type, we can define different flavored leaf nodes later.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mutable struct</span> Variable&#123;T&#125; &lt;: LeafNode</span><br><span class="line">    value::T</span><br><span class="line">    grad::T</span><br><span class="line"></span><br><span class="line">    Variable(val::T) <span class="keyword">where</span> T = new&#123;T&#125;(val)</span><br><span class="line">    Variable(val::T, grad::T) <span class="keyword">where</span> T = new&#123;T&#125;(val)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>Here, we use <a target="_blank" rel="noopener" href="https://docs.julialang.org/en/v1/manual/constructors/#Incomplete-Initialization-1">incomplete initialization</a>, since we don’t really need to allocate a memory for the gradient at the beginning, we can just take the ownership of a temporary variable’s memory later.</p>
<h3 id="Other-Nodes"><a href="#Other-Nodes" class="headerlink" title="Other Nodes"></a>Other Nodes</h3><p>Well, now we have some leaf nodes, but we need to store operations and their output for later use, so firstly, I define something called <code>Node</code></p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Node&#123;FT &lt;: <span class="built_in">Function</span>, ArgsT &lt;: <span class="built_in">Tuple</span>, KwargsT &lt;: <span class="built_in">NamedTuple</span>&#125; &lt;: AbstractNode</span><br><span class="line">    f::FT</span><br><span class="line">    args::ArgsT</span><br><span class="line">    kwargs::KwargsT</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>It is a subtype of <code>AbstractNode</code>, and it stores a function call’s arguments and keywords. However, we will need to consider<br><code>broadcast</code> and normal function calls, they are actually different, therefore we should not directly store the function, thus, so let’s write some <code>traits</code>:</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract type</span> Operator <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> Trait</span><br><span class="line"><span class="keyword">import</span> YAAD: Operator</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="built_in">Method</span>&#123;FT&#125; &lt;: Operator</span><br><span class="line">    f::FT</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Broadcasted&#123;FT&#125; &lt;: Operator</span><br><span class="line">    f::FT</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span> <span class="comment"># Trait</span></span><br></pre></td></tr></table></figure>
<p>Now we change <code>Function</code> to <code>Operator</code></p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Node&#123;FT &lt;: Operator, ArgsT &lt;: <span class="built_in">Tuple</span>, KwargsT &lt;: <span class="built_in">NamedTuple</span>&#125; &lt;: AbstractNode</span><br><span class="line">    f::FT</span><br><span class="line">    args::ArgsT</span><br><span class="line">    kwargs::KwargsT</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>And we may make some constructors for convenience, since most <code>f</code>s will be method calls rather than broadcasts or self-defined<br>operators, and we usually don’t need the keyword arguments either:</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># wrap function to Method</span></span><br><span class="line">Node(f::<span class="built_in">Function</span>, args, kwargs) = Node(Trait.<span class="built_in">Method</span>(f), args, kwargs)</span><br><span class="line">Node(op, args) = Node(op, args, <span class="built_in">NamedTuple</span>())</span><br></pre></td></tr></table></figure>
<p>In fact, <code>Node</code> is actually just a trait for some object (some subtype of <code>Operator</code>), we haven’t<br>defined the type that store the output of each node in the graph, so here let’s define a <code>CachedNode</code><br>which will cache the forward evaluation result of <code>Node</code>:</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mutable struct</span> CachedNode&#123;NT &lt;: AbstractNode, OutT&#125; &lt;: AbstractNode</span><br><span class="line">    node::NT</span><br><span class="line">    output::OutT</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>So, to store the forward evaluation result of a <code>Node</code> with <code>CachedNode</code> when it is constructed, we need to forward propagate<br>the comput-graph recorded in <code>Node</code> and assign it to the cache:</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> CachedNode(f, args...; kwargs...)</span><br><span class="line">    node = Node(f, args, kwargs.data) <span class="comment"># this constructs a Node</span></span><br><span class="line">    output = forward(node)</span><br><span class="line">    CachedNode(node, output)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="Evaluations"><a href="#Evaluations" class="headerlink" title="Evaluations"></a>Evaluations</h2><p>The evaluation is the most important part, because we want to define our rules of evaluation in an extensible way, and<br>try to make it efficient. Luckily, in Julia, we have <strong>multiple dispatch</strong>! Let’s make use of it!</p>
<h3 id="Forward-Evaluation"><a href="#Forward-Evaluation" class="headerlink" title="Forward Evaluation"></a>Forward Evaluation</h3><p>But how do we <strong>forward evaluate</strong> a <code>Node</code>? This depends on what kind of method is implemented for this generic function <code>forward</code>:</p>
<ol>
<li>If input is a <code>Node</code>, we re-dispatch this method to its operator’s forward method (while it forward evaluates the <code>args</code> and <code>kwargs</code>):</li>
</ol>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">forward(node::Node) = forward(node.f, map(forward, node.args)...; map(forward, node.kwargs)...)</span><br></pre></td></tr></table></figure>
<p>This will allow us to tweak the forward evaluation by simply implementing a method for the generic function <code>forward</code>, e.g, if we don’t want to directly calculate the result of a linear operator $\mathbf{W}\mathbf{x} + \mathbf{b}$ rather than store two nodes separately (a matrix-vector multiplication <code>*</code> and an add function <code>+</code>).</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Linear &lt;: Operator</span><br><span class="line">  w::<span class="built_in">Matrix</span>&#123;<span class="built_in">Float64</span>&#125;</span><br><span class="line">  b::<span class="built_in">Vector</span>&#123;<span class="built_in">Float64</span>&#125;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">forward(op::Linear, x::<span class="built_in">Vector</span>&#123;<span class="built_in">Float64</span>&#125;) = op.w * x + b</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>If input is a <code>CachedNode</code>, this means our user is evaluating this node for the second time (since we calculate the result when construct it), we will update its output</li>
</ol>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">forward(node::CachedNode) = (node.output = forward(node.node))</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>However, for simple function calls, we don’t want to write something like</li>
</ol>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> forward(::<span class="built_in">Method</span>&#123;typeof(sin)&#125;, x)</span><br><span class="line">  sin(x)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>each time, let’s make it simpler, by re-dispatching an operator’s <code>forward</code> method to a function call:</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">forward(op::Operator, args...; kwargs...) = op.f(args...; kwargs...)</span><br></pre></td></tr></table></figure>
<p>This means, as long as, the operator defines its own call method, it does not need to implement a method for <code>forward</code>, e.g</p>
<p>We can just define the call method for <code>Linear</code> rather than defining a method for <code>forward</code>:</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(op::Linear)(x::<span class="built_in">Vector</span>) = op.w * x + b</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>There could be some constants in the <code>Node</code>, e.g when we call <code>Variable(2.0) + 1.0</code>, this <code>1.0</code> is actually a constant, therefore, we can just return it, when the input is not part of the computational graph (not a subtype of <code>AbstractNode</code>) and define a default method for <code>AbstractNode</code> for better error messages.</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">forward(x) &#x3D; x</span><br><span class="line">forward(x::NT) where &#123;NT &lt;: AbstractNode&#125; &#x3D; error(&quot;forward method is not implemented for node type: $NT&quot;)</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>For leaf nodes, they should directly return their value, but we might use another kind of leaf node to make the non-PyTorch lover<br>happy in the future, so let’s define a generic function <code>value</code> to get this property:</li>
</ol>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">value(x) = x</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> value(x::T) <span class="keyword">where</span> &#123;T &lt;: AbstractNode&#125;</span><br><span class="line">    error(</span><br><span class="line">        <span class="string">&quot;Expected value in this node <span class="variable">$x</span> of type <span class="variable">$T</span> &quot;</span>,</span><br><span class="line">        <span class="string">&quot;check if you defined a non-cached node&quot;</span>,</span><br><span class="line">        <span class="string">&quot; or overload value function for your node.&quot;</span></span><br><span class="line">    )</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">value(x::Variable) = x.value</span><br><span class="line">value(x::CachedNode) = value(x.output)</span><br></pre></td></tr></table></figure>
<p>And leaf nodes’ <code>forward</code> directly return its value:</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">forward(node::LeafNode) = value(node)</span><br></pre></td></tr></table></figure>
<p>Okay! We have defined all we need for <code>forward</code> evaluation, now let’s try to implement backward evaluation.</p>
<h3 id="Backward-Evaluation"><a href="#Backward-Evaluation" class="headerlink" title="Backward Evaluation"></a>Backward Evaluation</h3><p>The backward evaluation is actually similar to forward evaluation, we will call backward recursively on each node and its <code>args</code> (no, I’m not going to support <code>backward</code> on <code>kwargs</code> here, XD).</p>
<p>Firstly, for <code>LeafNode</code>, this is simple, e.g <code>Variable</code> will just take the <code>grad</code></p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> backward(x::Variable, grad)</span><br><span class="line">    <span class="keyword">if</span> isdefined(x, :grad)</span><br><span class="line">        x.grad += grad</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        x.grad = grad</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="literal">nothing</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>We will check if this <code>grad</code> member is defined (it is incomplete initialized!), if it is not, we will just use the memory of<br>this gradient, or we can add it to the current gradient, just like PyTorch’s <code>Variable</code> (or <code>Tensor</code> after v0.4).</p>
<p>And now, we need to define how to backward evaluate a <code>CachedNode</code>:</p>
<ol>
<li>We gather the gradients of inputs from a function called <code>gradient</code></li>
<li>We put each corresponding gradient to sub-node of current node and call their <code>backward</code></li>
</ol>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> backward(node::CachedNode, f, grad)</span><br><span class="line">    grad_inputs = gradient(node, grad)</span><br><span class="line">    <span class="keyword">for</span> (each, each_grad) <span class="keyword">in</span> zip(args(node), grad_inputs)</span><br><span class="line">        backward(each, each_grad)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="literal">nothing</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>Oh, you might want to add some assertion to output a better error message here, we will check the type of gradient and output and also their size here, in most cases, gradient should have the exact same<br>type and size as output:</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">backward_type_assert(node::CachedNode&#123;&lt;:AbstractNode, T&#125;, grad::T) <span class="keyword">where</span> T = <span class="literal">true</span></span><br><span class="line">backward_type_assert(node::CachedNode&#123;&lt;:AbstractNode, T1&#125;, grad::T2) <span class="keyword">where</span> &#123;T1, T2&#125; =</span><br><span class="line">    error(<span class="string">&quot;Gradient is expected to have the same&quot;</span>,</span><br><span class="line">          <span class="string">&quot; type with outputs, expected <span class="variable">$T1</span>&quot;</span>,</span><br><span class="line">          <span class="string">&quot; got <span class="variable">$T2</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>but for subtype of <code>AbstractArray</code>, we can just allow them to have the same static parameter (tensor rank and data type), because we will probably be dealing with <code>SubArray</code> and <code>Array</code> for some operators, which does not really matters</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># exclude arrays</span></span><br><span class="line">backward_type_assert(node::CachedNode&#123;&lt;:AbstractNode, T1&#125;, grad::T2) <span class="keyword">where</span></span><br><span class="line">    &#123;T, N, T1 &lt;: <span class="built_in">AbstractArray</span>&#123;T, N&#125;, T2 &lt;: <span class="built_in">AbstractArray</span>&#123;T, N&#125;&#125; = <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>Finally we check the size of the gradients and outputs</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> backward_size_assert(node::CachedNode, grad)</span><br><span class="line">    size(node.output) == size(grad) ||</span><br><span class="line">        error(</span><br><span class="line">            <span class="string">&quot;gradient should have the same size with output,&quot;</span>,</span><br><span class="line">            <span class="string">&quot; expect size <span class="subst">$(size(node.output)</span>), got <span class="subst">$(size(grad)</span>)&quot;</span></span><br><span class="line">        )</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>In Julia, there is a compiler option to turn bounds check off. We sometimes don’t actually need to check bounds at runtime<br>so we put this assertion in <code>@boundscheck</code>. It looks like:</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> backward(node::CachedNode, f, grad)</span><br><span class="line">    backward_type_assert(node, grad)</span><br><span class="line">    <span class="comment"># TODO: replace with @assert when there is a compiler option for it</span></span><br><span class="line">    <span class="meta">@boundscheck</span> backward_size_assert(node, grad)</span><br><span class="line"></span><br><span class="line">    grad_inputs = gradient(node, grad)</span><br><span class="line">    <span class="keyword">for</span> (each, each_grad) <span class="keyword">in</span> zip(args(node), grad_inputs)</span><br><span class="line">        backward(each, each_grad)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="literal">nothing</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>OK, now, let’s think about how to return the gradient, I would prefer our AD be highly extensible by taking advantage of  Julia’s <strong>multiple dispatch</strong>, and I will only need to define the gradient by defining different methods for <code>gradient</code>, e.g</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradient(::typeof(sin), grad, output, x) = grad * cos(x)</span><br></pre></td></tr></table></figure>
<p>This can be implemented in the same way as <code>forward</code>: re-dispatch the method to different syntax:</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradient(x::CachedNode, grad) = gradient(x.node.f, grad, x.output, map(value, x.node.args)...; map(value, x.node.kwargs)...)</span><br></pre></td></tr></table></figure>
<p>Here we dispatch the <code>gradient</code> of a <code>CachedNode</code> directly to a method implemented for <code>Operator</code>, but we have the same situation with <code>forward</code>, we don’t want to write <code>Method</code> trait each time</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gradient(x::Operator, grad, output, args...; kwargs...) =</span><br><span class="line">    gradient(x.f, grad, output, args...; kwargs...)</span><br></pre></td></tr></table></figure>
<p>Finally, define a default error massage:</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gradient(fn, grad, output, args...; kwargs...) =</span><br><span class="line">    error(</span><br><span class="line">        <span class="string">&quot;gradient of operator <span class="variable">$fn</span> is not defined\n&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Possible Fix:\n&quot;</span>,</span><br><span class="line">        <span class="string">&quot;define one of the following:\n&quot;</span>,</span><br><span class="line">        <span class="string">&quot;1. gradient(::typeof(<span class="variable">$fn</span>), grad, output, args...; kwargs...)\n&quot;</span>,</span><br><span class="line">        <span class="string">&quot;2. gradient(op::Trait.Method&#123;typeof(<span class="variable">$fn</span>)&#125;, grad, output, args...; kwargs...)\n&quot;</span>,</span><br><span class="line">        <span class="string">&quot;3. gradient(op::Trait.Broadcasted&#123;typeof(<span class="variable">$fn</span>)&#125;, grad, output, args...; kwargs...)\n&quot;</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
<p>So in this way, when we implement a specific method of some types for <code>gradient</code>, Julia will auto dispatch gradient to that method, e.g</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># I re-define the concrete type `Linear` here in order to store the gradient</span></span><br><span class="line"><span class="keyword">struct</span> Linear &lt;: Operator</span><br><span class="line">  w::Variable&#123;<span class="built_in">Matrix</span>&#123;<span class="built_in">Float64</span>&#125;&#125;</span><br><span class="line">  b::Variable&#123;<span class="built_in">Vector</span>&#123;<span class="built_in">Float64</span>&#125;&#125;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> gradient(op::Linear, grad, output, x)</span><br><span class="line">  grad_w, grad_b = <span class="comment"># some gradient expression to calculate the gradient of w and b</span></span><br><span class="line">  backward(op.w, grad_w) <span class="comment"># update gradient of w</span></span><br><span class="line">  backward(op.w, grad_b) <span class="comment"># update gradient of b</span></span><br><span class="line"></span><br><span class="line">  grad_input = <span class="comment"># calculate the gradient of input</span></span><br><span class="line">  grad_input <span class="comment"># return the gradient of input</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>Umm, and finally, I would like to have an eye-candy function to construct a node (but this depends on you, it is not actually necessary):</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">register(f, args...; kwargs...) = CachedNode(f, args...; kwargs...)</span><br></pre></td></tr></table></figure>
<p>Okay, let’s try to register an operator now!</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base.sin(x::AbstractNode) = register(Base.sin, x)</span><br><span class="line">gradient(::typeof(Base.sin), grad, output, x) = (grad * cos(x), )</span><br></pre></td></tr></table></figure>
<p><strong>Remember we assumed gradient returns several gradients</strong>, the return of <code>gradient</code> has to be an iteratable of gradients.</p>
<h2 id="Broadcast"><a href="#Broadcast" class="headerlink" title="Broadcast"></a>Broadcast</h2><p>However, for above gradients for scalars, this will just work. It won’t work for arrays. We will need to re-dispatch broadcast in Julia.</p>
<p>Let me introduce some basic concepts of the interface of broadcast in Julia first, and then we will find a very easy way<br>to implement AD for broadcast:</p>
<p>The whole broadcast mechanism is implemented in a module <code>Broadcast</code> in <code>Base</code>, each different type has its own <code>BroadcastStyle</code> (this is a trait). So what we need to do, is just to implement our own broadcast style and construct a<br><code>CachedNode</code> instead directly broadcasting the operation.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ComputGraphStyle &lt;: Broadcast.BroadcastStyle <span class="keyword">end</span></span><br><span class="line">Base.BroadcastStyle(::<span class="built_in">Type</span>&#123;&lt;:AbstractNode&#125;) = ComputGraphStyle()</span><br><span class="line">Broadcast.BroadcastStyle(s::ComputGraphStyle, x::Broadcast.BroadcastStyle) = s</span><br></pre></td></tr></table></figure>
<p>However, this is not enough, in Julia broadcast is lazy-evaluated, which can fuse broadcast and provide better performance, we need to re-dispatch two interface: <code>broadcasted</code> and <code>materialize</code></p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Broadcast.broadcasted(::ComputGraphStyle, f, args...)</span><br><span class="line">    mt = Trait.Broadcasted(f)</span><br><span class="line">    register(mt, args...)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">Broadcast.materialize(x::AbstractNode) = register(Broadcast.materialize, x)</span><br></pre></td></tr></table></figure>
<p>And we let <code>materialize</code> directly return the gradient during backward evaluation:</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> backward(node::CachedNode, ::typeof(Broadcast.materialize), grad)</span><br><span class="line">    backward_type_assert(node, grad)</span><br><span class="line">    <span class="meta">@boundscheck</span> backward_size_assert(node, grad)</span><br><span class="line">    backward(node.node.args[<span class="number">1</span>], grad) <span class="comment"># materialize only has one arguments, we don&#x27;t need the for loop</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>Now, if you try to broadcast with this AD, you would find that the assertion we defined in <code>backward</code> is quite annoying (because lazy evaluation, its output is not actually the real output, but a middle type), let’s mute them for broadcast:</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> backward(node::CachedNode, ::Trait.Broadcasted, grad)</span><br><span class="line">    grad_inputs = gradient(node, grad)</span><br><span class="line">    <span class="keyword">for</span> (each, each_grad) <span class="keyword">in</span> zip(args(node), grad_inputs)</span><br><span class="line">        backward(each, each_grad)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="literal">nothing</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="Add-more-operators-for-FREE"><a href="#Add-more-operators-for-FREE" class="headerlink" title="Add more operators for FREE!"></a>Add more operators for FREE!</h2><p>There is a Julia package called <code>DiffRules</code>, it contains quite a lot differentiation rules defined as Julia <code>Expr</code>, so we can just use code generation to generate operators with it rather than define them ourselves:</p>
<p>The rules are in <code>DiffRules.DEFINED_DIFFRULES</code>, so we will just iterate through its key</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (mod, name, nargs) <span class="keyword">in</span> keys(DiffRules.DEFINED_DIFFRULES)</span><br><span class="line">  <span class="comment"># code generation</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>the first argument <code>mod</code> is the module’s name, like for <code>sin</code>, it is actually in <code>Base</code>, so the <code>mod</code> is <code>Base</code> and<br><code>name</code> is the function’s name, <code>nargs</code> means the number of arguments, in <code>DiffRules</code>, there are only single argument functions<br>and double arguments functions.</p>
<p>So the code generation will look like</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (mod, name, nargs) <span class="keyword">in</span> keys(DiffRules.DEFINED_DIFFRULES)</span><br><span class="line">    f_ex_head = <span class="built_in">Expr</span>(:., mod, <span class="built_in">QuoteNode</span>(name))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> nargs == <span class="number">1</span></span><br><span class="line">        df_ex = DiffRules.diffrule(mod, name, :x)</span><br><span class="line"></span><br><span class="line">        name === :abs &amp;&amp; <span class="keyword">continue</span> <span class="comment"># exclude abs, it cannot be directly broadcasted</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">@eval</span> <span class="keyword">begin</span></span><br><span class="line">            $(f_ex_head)(x::AbstractNode) = register($(f_ex_head), x)</span><br><span class="line">            gradient(::typeof($(f_ex_head)), grad, output, x) = (grad * $df_ex, )</span><br><span class="line">            gradient(mt::Trait.Broadcasted&#123;typeof($f_ex_head)&#125;, grad, output, x) = (@.(grad * $(df_ex)), )</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">elseif</span> nargs == <span class="number">2</span></span><br><span class="line">        df_ex = DiffRules.diffrule(mod, name, :x, :y)</span><br><span class="line"></span><br><span class="line">        <span class="meta">@eval</span> <span class="keyword">begin</span></span><br><span class="line"></span><br><span class="line">            $(f_ex_head)(x1::AbstractNode, x2) = register($f_ex_head, x1, x2)</span><br><span class="line">            $(f_ex_head)(x1, x2::AbstractNode) = register($f_ex_head, x1, x2)</span><br><span class="line">            $(f_ex_head)(x1::AbstractNode, x2::AbstractNode) = register($f_ex_head, x1, x2)</span><br><span class="line"></span><br><span class="line">            gradient(::typeof($f_ex_head), grad, output, x, y) =</span><br><span class="line">                (grad * $(df_ex[<span class="number">1</span>]), grad * $(df_ex[<span class="number">2</span>]))</span><br><span class="line">            gradient(::Trait.Broadcasted&#123;typeof($f_ex_head)&#125;, grad, output, x, y) =</span><br><span class="line">                (@.(grad * ($(df_ex[<span class="number">1</span>]))), @.(grad * $(df_ex[<span class="number">2</span>])))</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="meta">@info</span> <span class="string">&quot;unknown operator <span class="variable">$name</span>&quot;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>For how to use code generation in Julia, I would recommend the official documentation to get a better understanding of it: <a target="_blank" rel="noopener" href="https://docs.julialang.org/en/v1/manual/metaprogramming/#Code-Generation-1">Code Generation</a>. I escape <code>abs</code> here because the differentiation expression of <code>abs</code> generated by <code>DiffRules</code> can not be directly broadcasted by <code>@.</code> (this macro add a broadcast mark <code>.</code> to every function call), so I have to implement its gradient manually. But <code>DiffRules</code> will generate most of the math function’s gradient for you!</p>
<h2 id="Polish"><a href="#Polish" class="headerlink" title="Polish"></a>Polish</h2><p>We roughly implemented the core functionality of an AD, but there’s still quite a lot to do to make it look and feel better.</p>
<p>I defined better printing later here: <a target="_blank" rel="noopener" href="https://github.com/Roger-luo/YAAD.jl/blob/master/src/show.jl">show.jl</a>, the basic idea is to re-dispatch our nodes via several traits, so we can insert a type into another type tree, e.g as subtype of <code>AbstractArray</code> and then make use of existing printing methods.</p>
<p>Then, to implement unit tests, I copied the <code>gradcheck</code> function from <code>PyTorch</code>, which will calculate the jacobian of an operator with the AD package and compare it with the numerical jacobian.</p>
<h2 id="Benchmark"><a href="#Benchmark" class="headerlink" title="Benchmark"></a>Benchmark</h2><p>Okay, it is done! With only about 200~300 lines Julia, what can we get? Actually, I thought it would be just a toy, but<br>it is actually amazing, when I tried to use it for my own work:</p>
<p>So I need to calculate something called <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Matrix_product_state">matrix product state</a>, well, I’m not going to talk about quantum physics, so in short, it is just some rank-3 tensors (3 dimensional array), and we will need to calculate something like the following expression:</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tr(x1 * x2 * x3)</span><br></pre></td></tr></table></figure>
<p>where <code>x1</code>, <code>x2</code>, <code>x3</code> are just matrices.</p>
<p>So I implemented the gradient of <code>tr</code> and matrix multiplication:</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Base.:(*)(lhs::AbstractNode, rhs) = register(Base.:(*), lhs, rhs)</span><br><span class="line">Base.:(*)(lhs, rhs::AbstractNode) = register(Base.:(*), lhs, rhs)</span><br><span class="line">Base.:(*)(lhs::AbstractNode, rhs::AbstractNode) = register(Base.:(*), lhs, rhs)</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LinearAlgebra</span><br><span class="line"></span><br><span class="line">LinearAlgebra.tr(x::AbstractNode) = register(LinearAlgebra.tr, x)</span><br><span class="line">gradient(::typeof(tr), grad, output, x) = (grad * <span class="built_in">Matrix</span>(I, size(x)), )</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> gradient(::typeof(*), grad, output, lhs::<span class="built_in">AbstractVecOrMat</span>, rhs::<span class="built_in">AbstractVecOrMat</span>)</span><br><span class="line">    grad * transpose(rhs), transpose(lhs) * grad</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>Now let’s benchmark <code>tr(x1 * x2)</code> on the CPU with other packages, with the following function call</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Zygote.<span class="meta">@grad</span> LinearAlgebra.tr(x) = LinearAlgebra.tr(x), Δ-&gt; (Δ * <span class="built_in">Matrix</span>(I, size(x)), )</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> bench_tr_mul_yaad(x1, x2)</span><br><span class="line">    z = tr(x1 * x2)</span><br><span class="line">    YAAD.backward(z)</span><br><span class="line">    x1.grad, x2.grad</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> bench_tr_mul_autograd(x1, x2)</span><br><span class="line">    z = AutoGrad.<span class="meta">@diff</span> tr(x1 * x2)</span><br><span class="line">    AutoGrad.grad(z, x1), AutoGrad.grad(z, x2)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> bench_tr_mul_zygote(x1, x2)</span><br><span class="line">    Zygote.gradient((x1, x2)-&gt;tr(x1 * x2), x1, x2)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> bench_tr_mul_flux(x1, x2)</span><br><span class="line">    z = tr(x1 * x2)</span><br><span class="line">    back!(z, <span class="number">1</span>)</span><br><span class="line">    Tracker.grad(x1), Tracker.grad(x2)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>and in PyTorch (our interface is quite similar to PyTorch, isn’t it?)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bench_tr_mul_torch</span>(<span class="params">x1, x2</span>):</span></span><br><span class="line">    z = torch.trace(torch.matmul(x1, x2))</span><br><span class="line">    z.backward()</span><br><span class="line">    <span class="keyword">return</span> x1.grad, x2.grad</span><br></pre></td></tr></table></figure>
<p>In Julia, we use <code>BenchmarkTools</code> to measure the time, and in Python we can use the magic command <code>timeit</code> in ipython.</p>
<p>The value is defined as follows</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xv, yv = rand(<span class="number">30</span>, <span class="number">30</span>), rand(<span class="number">30</span>, <span class="number">30</span>)</span><br><span class="line">yaad_x, yaad_y = YAAD.Variable(xv), YAAD.Variable(yv)</span><br><span class="line">autograd_x, autograd_y = AutoGrad.Param(xv), AutoGrad.Param(yv)</span><br><span class="line">flux_x, flux_y = Flux.param(xv), Flux.param(yv)</span><br></pre></td></tr></table></figure>
<p>Before we benchmark other packages, I also wrote a baseline function, which calculates the gradient manually:</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> bench_tr_mul_base(x1, x2)</span><br><span class="line">    z1 = x1 * x2</span><br><span class="line">    z2 = tr(z1)</span><br><span class="line"></span><br><span class="line">    grad_z1 = <span class="built_in">Matrix</span>&#123;eltype(z1)&#125;(I, size(z1))</span><br><span class="line">    grad_z1 * transpose(x2), transpose(x1) * grad_z1</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>And then tests it with <code>@benchmark</code>, which will run this function multiple times</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; <span class="meta">@benchmark</span> bench_tr_mul_autograd(autograd_x, autograd_y)</span><br><span class="line">BenchmarkTools.Trial:</span><br><span class="line">  memory estimate:  <span class="number">33.20</span> KiB</span><br><span class="line">  allocs estimate:  <span class="number">82</span></span><br><span class="line">  --------------</span><br><span class="line">  minimum time:     <span class="number">50.218</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  median time:      <span class="number">62.364</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  mean time:        <span class="number">90.422</span> μs (<span class="number">9.86</span>% GC)</span><br><span class="line">  maximum time:     <span class="number">55.386</span> ms (<span class="number">99.86</span>% GC)</span><br><span class="line">  --------------</span><br><span class="line">  samples:          <span class="number">10000</span></span><br><span class="line">  evals/sample:     <span class="number">1</span></span><br><span class="line"></span><br><span class="line">julia&gt; <span class="meta">@benchmark</span> bench_tr_mul_yaad(yaad_x, yaad_y)</span><br><span class="line">BenchmarkTools.Trial:</span><br><span class="line">  memory estimate:  <span class="number">51.50</span> KiB</span><br><span class="line">  allocs estimate:  <span class="number">16</span></span><br><span class="line">  --------------</span><br><span class="line">  minimum time:     <span class="number">10.387</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  median time:      <span class="number">13.429</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  mean time:        <span class="number">24.273</span> μs (<span class="number">45.13</span>% GC)</span><br><span class="line">  maximum time:     <span class="number">55.963</span> ms (<span class="number">99.96</span>% GC)</span><br><span class="line">  --------------</span><br><span class="line">  samples:          <span class="number">10000</span></span><br><span class="line">  evals/sample:     <span class="number">1</span></span><br><span class="line"></span><br><span class="line">julia&gt; <span class="meta">@benchmark</span> bench_tr_mul_zygote(xv, yv)</span><br><span class="line">BenchmarkTools.Trial:</span><br><span class="line">  memory estimate:  <span class="number">29.98</span> KiB</span><br><span class="line">  allocs estimate:  <span class="number">10</span></span><br><span class="line">  --------------</span><br><span class="line">  minimum time:     <span class="number">42.527</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  median time:      <span class="number">46.640</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  mean time:        <span class="number">56.996</span> μs (<span class="number">15.31</span>% GC)</span><br><span class="line">  maximum time:     <span class="number">51.718</span> ms (<span class="number">99.90</span>% GC)</span><br><span class="line">  --------------</span><br><span class="line">  samples:          <span class="number">10000</span></span><br><span class="line">  evals/sample:     <span class="number">1</span></span><br><span class="line"></span><br><span class="line">julia&gt; <span class="meta">@benchmark</span> bench_tr_mul_base(xv, yv)</span><br><span class="line">BenchmarkTools.Trial:</span><br><span class="line">  memory estimate:  <span class="number">28.78</span> KiB</span><br><span class="line">  allocs estimate:  <span class="number">5</span></span><br><span class="line">  --------------</span><br><span class="line">  minimum time:     <span class="number">6.413</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  median time:      <span class="number">8.201</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  mean time:        <span class="number">12.215</span> μs (<span class="number">31.57</span>% GC)</span><br><span class="line">  maximum time:     <span class="number">11.012</span> ms (<span class="number">99.87</span>% GC)</span><br><span class="line">  --------------</span><br><span class="line">  samples:          <span class="number">10000</span></span><br><span class="line">  evals/sample:     <span class="number">5</span></span><br><span class="line"></span><br><span class="line">julia&gt; <span class="meta">@benchmark</span> bench_tr_mul_flux(flux_x, flux_y)</span><br><span class="line">BenchmarkTools.Trial:</span><br><span class="line">  memory estimate:  <span class="number">30.25</span> KiB</span><br><span class="line">  allocs estimate:  <span class="number">24</span></span><br><span class="line">  --------------</span><br><span class="line">  minimum time:     <span class="number">8.009</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  median time:      <span class="number">10.002</span> μs (<span class="number">0.00</span>% GC)</span><br><span class="line">  mean time:        <span class="number">14.412</span> μs (<span class="number">30.14</span>% GC)</span><br><span class="line">  maximum time:     <span class="number">16.286</span> ms (<span class="number">99.87</span>% GC)</span><br><span class="line">  --------------</span><br><span class="line">  samples:          <span class="number">10000</span></span><br><span class="line">  evals/sample:     <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>and for PyTorch (version v0.4.1)</p>
<figure class="highlight ipython"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">4</span>]: x = torch.rand(<span class="number">30</span>, <span class="number">30</span>, dtype=torch.float64, requires_grad=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: y = torch.rand(<span class="number">30</span>, <span class="number">30</span>, dtype=torch.float64, requires_grad=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: %timeit bench_tr_mul_torch(x, y)</span><br><span class="line"><span class="number">76.8</span> µs ± <span class="number">1.68</span> µs per loop (mean ± std. dev. of <span class="number">7</span> runs, <span class="number">10000</span> loops each)</span><br></pre></td></tr></table></figure>
<p>Our implementation is not bad, huh? Only about 4~5 μs slower than the baseline due to the dynamic construction of our computational graph in runtime and Flux is the fastest (it is implemented in similar approach), amazing! It is about 5x faster than other packages in either Julia or Python/C++.</p>
<p>So, as you see, writing an AD package can be super sweet in Julia with multiple dispatch. You can actually write your own AD with reasonable performance in Julia like a pro!</p>
<h2 id="Acknowledgement"><a href="#Acknowledgement" class="headerlink" title="Acknowledgement"></a>Acknowledgement</h2><p>Thanks for Keno for benchmarking advice on Zygote, I was actually quite confused about the performance and submitted an issue here: <a target="_blank" rel="noopener" href="https://github.com/FluxML/Zygote.jl/issues/28">Zygote.jl/issues/28</a></p>
<p>And thanks for the <a target="_blank" rel="noopener" href="https://github.com/JuliaGraphics/Luxor.jl">Luxor.jl</a> package, I use this for plotting the animation in this blog post. You might want to check my ugly plotting script here: <a target="_blank" rel="noopener" href="https://github.com/Roger-luo/YAAD.jl/blob/master/docs/plot.jl">plot.jl</a></p>
<p>Finally, thanks for Travis Ashworth for helping me on polishing the blog post. This is actually my first time to blog in English, and I didn’t check this blog post carefully. And now I have two Travis (another Travis is the Travis-CI which builds my blog automatically.)</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Xiu-Zhe (Roger) Luo</p>
  <div class="site-description" itemprop="description">Where I writes about Machine Learning, Quanutm Physics, and more.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Roger-luo" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Roger-luo" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/rogerluorl18" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;rogerluorl18" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Xiu-Zhe (Roger) Luo</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://blog-rogerluo-me.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>

</body>
</html>
